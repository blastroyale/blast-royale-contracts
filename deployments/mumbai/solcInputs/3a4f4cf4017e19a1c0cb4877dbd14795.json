{
  "language": "Solidity",
  "sources": {
    "contracts/BlastBoxMarketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\n\nstruct Listing {\n    address owner;\n    bool isActive;\n    uint256 tokenId;\n    uint256 price;\n    IERC20 tokenAddress;\n}\n\n/// @title Blast Royale Token - $BLT\n/// @dev Based on OpenZeppelin Contracts.\ncontract BlastBoxMarketplace is ReentrancyGuard, Ownable, Pausable {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant DECIMAL_FACTOR = 100_00;\n\n    uint256 public listingCount;\n    uint256 public activeListingCount;\n    uint256 public fee1;\n    address public treasury1;\n    uint256 public fee2;\n    address public treasury2;\n    bool public isUsingMatic;\n\n    mapping(address => bool) public whitelistedTokens;\n    mapping(uint256 => Listing) public listings;\n    IERC721 public erc721Contract;\n\n    /// @notice Event Listed\n    event BlastboxListed(\n        uint256 listingId,\n        uint256 tokenId,\n        address seller,\n        uint256 price,\n        address payTokenAddress\n    );\n\n    /// @notice Event Delisted\n    event BlastboxDelisted(uint256 listingId, uint256 tokenId, address seller);\n\n    /// @notice EventBlastbox Sold\n    event BlastboxSold(\n        uint256 listingId,\n        uint256 tokenId,\n        address seller,\n        address buyer,\n        uint256 price,\n        uint256 fee1,\n        uint256 fee2\n    );\n\n    /// @notice Event Fee changed\n    event FeesChanged(\n        uint256 fee1,\n        address treasury1,\n        uint256 fee2,\n        address treasury2,\n        address changedBy\n    );\n\n    event WhitelistAdded(address[] whitelists);\n\n    event WhitelistRemoved(address[] whitelists);\n\n    /// @notice Token constructor\n    /// @dev Setup the two contracts it will interact with : ERC721 and ERC20\n    /// @param erc721Address Address of the NFT Contract.\n    constructor(IERC721 erc721Address) {\n        require(address(erc721Address) != address(0), Errors.NO_ZERO_ADDRESS);\n        erc721Contract = erc721Address;\n    }\n\n    /// @notice add a Listing to the Marketplace\n    /// @dev Creates a new entry for a Listing object and transfers the Token to the contract\n    /// @param tokenId NFT TokenId.\n    /// @param price Price in NFTs.\n    function addListing(\n        uint256 tokenId,\n        uint256 price,\n        IERC20 payTokenAddress\n    ) public nonReentrant whenNotPaused {\n        require(price != 0, Errors.NO_ZERO_VALUE);\n        if (address(payTokenAddress) != address(0)) {\n            require(\n                whitelistedTokens[address(payTokenAddress)],\n                Errors.TOKEN_NOT_WHITELISTED\n            );\n        }\n\n        uint256 listingId = listingCount;\n        listings[listingId] = Listing({\n            owner: _msgSender(),\n            isActive: true,\n            tokenId: tokenId,\n            price: price,\n            tokenAddress: payTokenAddress\n        });\n        listingCount = listingCount + 1;\n        activeListingCount = activeListingCount + 1;\n        erc721Contract.transferFrom(_msgSender(), address(this), tokenId);\n\n        emit BlastboxListed(\n            listingId,\n            tokenId,\n            _msgSender(),\n            price,\n            address(payTokenAddress)\n        );\n    }\n\n    /// @notice Remove a Listing from the Marketplace\n    /// @dev Marks Listing as not active object and transfers the Token back\n    /// @param listingId NFT Listing Id.\n    function removeListing(uint256 listingId) public nonReentrant {\n        Listing storage listing = listings[listingId];\n        require(\n            listing.owner == _msgSender() || owner() == _msgSender(),\n            Errors.NOT_OWNER\n        );\n        require(listing.isActive, Errors.LISTING_IS_NOT_ACTIVED);\n        listing.isActive = false;\n        erc721Contract.transferFrom(\n            address(this),\n            listing.owner,\n            listing.tokenId\n        );\n        activeListingCount = activeListingCount - 1;\n        emit BlastboxDelisted(listingId, listing.tokenId, listing.owner);\n    }\n\n    /// @notice Buys a listed NFT\n    /// @dev Trabsfers both the ERC20 token (price) and the NFT.\n    /// @param listingId NFT Listing Id.\n    function buy(uint256 listingId) public payable nonReentrant whenNotPaused {\n        require(listings[listingId].isActive, Errors.LISTING_IS_NOT_ACTIVED);\n\n        listings[listingId].isActive = false;\n        IERC20 payTokenAddress = listings[listingId].tokenAddress;\n        uint256 listedPrice = listings[listingId].price;\n        uint256 buyingFee1 = ((fee1 * listedPrice) / DECIMAL_FACTOR);\n        uint256 buyingFee2 = ((fee2 * listedPrice) / DECIMAL_FACTOR);\n\n        if (isUsingMatic) {\n            require(msg.value == listedPrice, Errors.INVALID_AMOUNT);\n            if (buyingFee1 > 0) {\n                (bool sent1, ) = payable(treasury1).call{value: buyingFee1}(\"\");\n                require(sent1, Errors.FAILED_TO_SEND_ETHER_TREASURY);\n            }\n            if (buyingFee2 > 0) {\n                (bool sent2, ) = payable(treasury2).call{value: buyingFee2}(\"\");\n                require(sent2, Errors.FAILED_TO_SEND_ETHER_COMPANY);\n            }\n            (bool sent, ) = payable(listings[listingId].owner).call{\n                value: listedPrice - buyingFee1 - buyingFee2\n            }(\"\");\n            require(sent, Errors.FAILED_TO_SEND_ETHER_USER);\n        } else {\n            require(msg.value == 0, Errors.INVALID_AMOUNT);\n            if (buyingFee1 > 0) {\n                payTokenAddress.safeTransferFrom(\n                    _msgSender(),\n                    treasury1,\n                    buyingFee1\n                );\n            }\n            if (buyingFee2 > 0) {\n                payTokenAddress.safeTransferFrom(\n                    _msgSender(),\n                    treasury2,\n                    buyingFee2\n                );\n            }\n            payTokenAddress.safeTransferFrom(\n                _msgSender(),\n                listings[listingId].owner,\n                listedPrice - buyingFee1 - buyingFee2\n            );\n        }\n        erc721Contract.transferFrom(\n            address(this),\n            _msgSender(),\n            listings[listingId].tokenId\n        );\n        activeListingCount = activeListingCount - 1;\n\n        emit BlastboxSold(\n            listingId,\n            listings[listingId].tokenId,\n            listings[listingId].owner,\n            _msgSender(),\n            listedPrice,\n            buyingFee1,\n            buyingFee2\n        );\n    }\n\n    /// @notice Sets a new Fee\n    /// @param _fee1 new Fee1.\n    /// @param _treasury1 New treasury1 address.\n    /// @param _fee2 new Fee2.\n    /// @param _treasury2 New treasury2 address.\n    function setFee(\n        uint256 _fee1,\n        address _treasury1,\n        uint256 _fee2,\n        address _treasury2\n    ) public onlyOwner {\n        require(_fee1 + _fee2 < DECIMAL_FACTOR, Errors.INVALID_PARAM);\n        require(_treasury1 != address(0), Errors.NO_ZERO_ADDRESS);\n        require(_treasury2 != address(0), Errors.NO_ZERO_ADDRESS);\n\n        fee1 = _fee1;\n        treasury1 = _treasury1;\n        fee2 = _fee2;\n        treasury2 = _treasury2;\n\n        emit FeesChanged(fee1, treasury1, fee2, treasury2, _msgSender());\n    }\n\n    function setWhitelistTokens(\n        address[] calldata _whitelist\n    ) external onlyOwner {\n        for (uint256 i = 0; i < _whitelist.length; i++) {\n            require(_whitelist[i] != address(0), Errors.NO_ZERO_ADDRESS);\n            whitelistedTokens[_whitelist[i]] = true;\n        }\n\n        emit WhitelistAdded(_whitelist);\n    }\n\n    function removeWhitelistTokens(\n        address[] calldata _whitelist\n    ) external onlyOwner {\n        for (uint256 i = 0; i < _whitelist.length; i++) {\n            require(_whitelist[i] != address(0), Errors.NO_ZERO_ADDRESS);\n            whitelistedTokens[_whitelist[i]] = false;\n        }\n\n        emit WhitelistRemoved(_whitelist);\n    }\n\n    function flipIsUsingMatic() external onlyOwner {\n        isUsingMatic = !isUsingMatic;\n    }\n\n    // @notice Pauses/Unpauses the contract\n    // @dev While paused, addListing, and buy are not allowed\n    // @param stop whether to pause or unpause the contract.\n    function pause(bool stop) external onlyOwner {\n        if (stop) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Errors library\n * @author JensonCollins\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\n * @dev Error messages prefix glossary:\n *  - VL = ValidationLogic\n *  - MATH = Math libraries\n *  - CT = Common errors between tokens (AToken, VariableDebtToken and StableDebtToken)\n *  - AT = AToken\n *  - SDT = StableDebtToken\n *  - VDT = VariableDebtToken\n *  - LP = LendingPool\n *  - LPAPR = LendingPoolAddressesProviderRegistry\n *  - LPC = LendingPoolConfiguration\n *  - RL = ReserveLogic\n *  - LPCM = LendingPoolCollateralManager\n *  - P = Pausable\n */\n\nlibrary Errors {\n    //common errors\n    string public constant NO_ZERO_ADDRESS = \"1\"; // Address cannot be zero\n    string public constant NO_ZERO_VALUE = \"2\"; // Value cannot be zero\n    string public constant NOT_OWNER = \"3\"; // Caller is not owner\n    string public constant NOT_EXIST_TOKEN_ID = \"4\"; // Token ID does not exist\n    string public constant INVALID_PARAM = \"5\"; // Invalid parameter\n    string public constant INVALID_AMOUNT = \"6\"; // In case msg.value amount is different as expected\n    string public constant FAILED_TO_SEND_ETHER_TREASURY = \"7\"; // Failed to send ether to treasury\n    string public constant FAILED_TO_SEND_ETHER_COMPANY = \"8\"; // Failed to send ether to company\n    string public constant USING_MATIC_NOW = \"9\"; // Using MATIC now\n    string public constant NOT_USING_MATIC_NOW = \"10\"; // Not using MATIC now\n\n    // AccessControl\n    string public constant MISSING_GAME_ROLE = \"11\"; // Caller does not have the GAME_ROLE role\n\n    // BlastEquipmentNFT contract\n    string public constant MAX_LEVEL_REACHED = \"12\"; // Max level reached\n    string public constant MAX_REPLICATION_COUNT_REACHED = \"24\"; // Max replication counter reached\n\n    // Marektplace contract\n    string public constant TOKEN_NOT_WHITELISTED = \"13\"; // Caller is not whitelisted\n    string public constant LISTING_IS_NOT_ACTIVED = \"14\"; // Listing is not actived\n    string public constant FAILED_TO_SEND_ETHER_USER = \"15\"; // Failed to send ether to user\n\n    // MarketplaceLootbox contract\n    string public constant MAX_LIMIT_REACHED = \"16\"; // Reached max limit\n    string public constant INVALID_MERKLE_PROOF = \"17\"; // Invalid merkle proof\n\n    // Lootbox contract\n    string public constant NOT_AVAILABLE_TO_OPEN = \"18\"; // Lootbox is not available to open\n\n    // CS contract\n    string public constant CS_EXPIRED_DEADLINE = \"19\"; // Invalid signature\n    string public constant CS_INVALID_SIGNATURE = \"20\"; // Invalid signature\n\n    // Replicator contract\n    string public constant NOT_READY_REPLICATE = \"21\"; // Not ready to replicate\n    string public constant NOT_READY_MORPH = \"22\"; // Not ready to morph\n    string public constant INVALID_HEX_CHARACTER = \"23\"; // Not ready to morph\n\n    // Vesting contract\n    string public constant INSUFFICIENT_TOKENS = \"25\"; // Insufficient tokens\n    string public constant DURATION_INVALID = \"26\"; // Duration is invalid\n    string public constant BENEFICIARY_OR_OWNER = \"27\"; // Beneficiary or owner\n    string public constant NOT_ENOUGH_TOKENS = \"28\"; // Not enough tokens\n    string public constant SCHEDULE_REVOKED = \"29\"; // Schedule revoked\n    string public constant NOT_REVOCABLE = \"30\"; // Not revocable\n    string public constant START_TIME_INVALID = \"31\"; // Start time is invalid\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Vesting/TokenVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { Errors } from \"./../libraries/Errors.sol\";\n\ncontract TokenVesting is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    event CreatedVestingSchedule(address user, bytes32 scheduleId);\n\n    /// <=============== STATE VARIABLES ===============>\n\n    /// Blast TOKEN\n    IERC20 public blastToken;\n\n    struct VestingSchedule {\n        // beneficiary of tokens after they are released\n        address beneficiary;\n        // start time of the vesting period\n        uint256 start;\n        // cliffStart time in seconds\n        uint256 cliffStart;\n        // duration of the vesting period in seconds\n        uint256 duration;\n        // the amount that is immediately vested at grant\n        uint256 immediateVestedAmount;\n        // total amount of tokens to be released at the end of the vesting EXCLUDING immediateVestedAmount\n        uint256 amountTotal;\n        // amount of tokens released\n        uint256 released;\n        // whether or not the vesting is revocable\n        bool revocable;\n        // whether or not the vesting has been revoked\n        bool revoked;\n    }\n\n    bytes32[] private vestingSchedulesIds;\n    mapping(bytes32 => VestingSchedule) private vestingSchedules;\n    uint256 private vestingSchedulesTotalAmount;\n    mapping(address => uint256) private holdersVestingCount;\n\n    event Released(\n        address beneficiary,\n        bytes32 vestingScheduleId,\n        uint256 amount,\n        uint256 releaseTimestamp\n    );\n    event Revoked(bytes32 vestingScheduleId, uint256 revokeTimestamp);\n\n    constructor(IERC20 _blastToken) {\n        blastToken = _blastToken;\n    }\n\n    /// <=============== MUTATIVE METHODS ===============>\n\n    /// @notice Creates a new vesting schedule for a beneficiary\n    function createVestingSchedule(\n        address _beneficiary,\n        uint256 _start,\n        uint256 _cliffDuration,\n        uint256 _duration,\n        uint256 _immediateReleaseAmount,\n        uint256 _amountTotal,\n        bool _revocable\n    ) external whenNotPaused onlyOwner {\n        require(_beneficiary != address(0), Errors.NO_ZERO_ADDRESS);\n        require(getWithdrawableAmount() >= (_amountTotal + _immediateReleaseAmount), Errors.INSUFFICIENT_TOKENS);\n        require(_duration > 0, Errors.DURATION_INVALID);\n        require(_amountTotal > 0, Errors.INVALID_AMOUNT);\n        require(_start > block.timestamp, Errors.START_TIME_INVALID);\n        require(_cliffDuration <= _duration, Errors.DURATION_INVALID);\n\n        bytes32 vestingScheduleId = computeNextVestingScheduleIdForHolder(\n            _beneficiary\n        );\n        uint256 cliff = _start + _cliffDuration;\n        vestingSchedules[vestingScheduleId] = VestingSchedule({\n            beneficiary: _beneficiary,\n            start: _start,\n            cliffStart: cliff,\n            duration: _duration,\n            immediateVestedAmount: _immediateReleaseAmount,\n            amountTotal: _amountTotal,\n            released: 0,\n            revocable: _revocable,\n            revoked: false\n        });\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount + _amountTotal + _immediateReleaseAmount;\n        vestingSchedulesIds.push(vestingScheduleId);\n        uint256 currentVestingCount = holdersVestingCount[_beneficiary];\n        holdersVestingCount[_beneficiary] = currentVestingCount + 1;\n\n        emit CreatedVestingSchedule(_beneficiary, vestingScheduleId);\n    }\n\n    /**\n     * @notice Revokes the vesting schedule for given identifier.\n     * @param vestingScheduleId the vesting schedule identifier\n     */\n    function revoke(bytes32 vestingScheduleId) external whenNotPaused onlyOwner {\n        VestingSchedule storage vestingSchedule = vestingSchedules[vestingScheduleId];\n        require(!vestingSchedule.revoked, Errors.SCHEDULE_REVOKED);\n        require(vestingSchedule.revocable, Errors.NOT_REVOCABLE);\n        uint256 releasableAmount = _computeReleasableAmount(vestingSchedule);\n        if (releasableAmount > 0) {\n            release(vestingScheduleId, releasableAmount);\n        }\n        uint256 unreleased = vestingSchedule.amountTotal -\n            vestingSchedule.released;\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount - unreleased;\n        vestingSchedule.revoked = true;\n        blastToken.safeTransfer(owner(), unreleased);\n\n        emit Revoked(vestingScheduleId, block.timestamp);\n    }\n\n    /// @notice Release vested amount of tokens.\n    function release(bytes32 vestingScheduleId, uint256 amount)\n        public\n        whenNotPaused\n        nonReentrant\n    {\n        VestingSchedule storage vestingSchedule = vestingSchedules[vestingScheduleId];\n        require(!vestingSchedule.revoked, Errors.SCHEDULE_REVOKED);\n        address beneficiary = vestingSchedule.beneficiary;\n        bool isBeneficiary = _msgSender() == beneficiary;\n        bool isOwner = _msgSender() == owner();\n        require(isBeneficiary || isOwner, Errors.BENEFICIARY_OR_OWNER);\n        uint256 releasableAmount = _computeReleasableAmount(vestingSchedule);\n        require(releasableAmount >= amount, Errors.NOT_ENOUGH_TOKENS);\n        vestingSchedule.released = vestingSchedule.released + amount;\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount - amount;\n        blastToken.safeTransfer(beneficiary, amount);\n        emit Released(_msgSender(), vestingScheduleId, amount, block.timestamp);\n    }\n\n    /// <=============== VIEWS ===============>\n\n    /**\n     * @dev Returns the amount of tokens that can be withdrawn by the owner.\n     * @return the amount of tokens\n     */\n    function getWithdrawableAmount() public view returns (uint256) {\n        return\n            blastToken.balanceOf(address(this)) - vestingSchedulesTotalAmount;\n    }\n\n    /**\n     * @dev Computes the next vesting schedule identifier for a given holder address.\n     */\n    function computeNextVestingScheduleIdForHolder(address holder)\n        public\n        view\n        returns (bytes32)\n    {\n        return\n            computeVestingScheduleIdForAddressAndIndex(\n                holder,\n                holdersVestingCount[holder]\n            );\n    }\n\n    /**\n     * @dev Computes the vesting schedule identifier for an address and an index.\n     */\n    function computeVestingScheduleIdForAddressAndIndex(\n        address holder,\n        uint256 index\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(holder, index));\n    }\n\n    /**\n     * @notice Computes the vested amount of tokens for the given vesting schedule identifier.\n     * @return the vested amount\n     */\n    function computeReleasableAmount(bytes32 vestingScheduleId)\n        external\n        view\n        returns (uint256)\n    {\n        require(!vestingSchedules[vestingScheduleId].revoked, Errors.SCHEDULE_REVOKED);\n        VestingSchedule storage vestingSchedule = vestingSchedules[\n            vestingScheduleId\n        ];\n        return _computeReleasableAmount(vestingSchedule);\n    }\n\n    /**\n     * @dev Computes the releasable amount of tokens for a vesting schedule.\n     * @return the amount of releasable tokens\n     */\n    function _computeReleasableAmount(VestingSchedule memory vestingSchedule)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 currentTime = block.timestamp;\n        if (currentTime < vestingSchedule.cliffStart) {\n            return vestingSchedule.immediateVestedAmount - vestingSchedule.released;\n        } else if (\n            currentTime >= vestingSchedule.cliffStart + vestingSchedule.duration\n        ) {\n            return\n                vestingSchedule.amountTotal +\n                vestingSchedule.immediateVestedAmount -\n                vestingSchedule.released;\n        } else {\n            uint256 timeFromStart = currentTime - vestingSchedule.cliffStart;\n            uint256 vestedAmount = vestingSchedule.amountTotal * timeFromStart / vestingSchedule.duration;\n            vestedAmount = vestedAmount + vestingSchedule.immediateVestedAmount - vestingSchedule.released;\n            return vestedAmount;\n        }\n    }\n\n    /**\n     * @notice Returns the vesting schedule information for a given identifier.\n     * @return the vesting schedule structure information\n     */\n    function getVestingSchedule(bytes32 vestingScheduleId)\n        public\n        view\n        returns (VestingSchedule memory)\n    {\n        return vestingSchedules[vestingScheduleId];\n    }\n\n    /**\n     * @notice Returns the vesting schedule information for a given holder and index.\n     * @return the vesting schedule structure information\n     */\n    function getVestingScheduleByAddressAndIndex(address holder, uint256 index)\n        external\n        view\n        returns (VestingSchedule memory)\n    {\n        return\n            getVestingSchedule(\n                computeVestingScheduleIdForAddressAndIndex(holder, index)\n            );\n    }\n\n    function pause(bool stop) external onlyOwner {\n        if (stop) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n}\n"
    },
    "contracts/Utilities/Upgrader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./../interfaces/IBlastEquipmentNFT.sol\";\nimport \"./Utility.sol\";\n\ncontract Upgrader is Utility {\n    using SafeERC20 for IERC20;\n\n    event LevelUpgraded(uint256 tokenId, address owner, uint256 newLevel);\n\n    // Calculation related variables\n    struct Attributes {\n        uint16[10] pricePerRarity;\n        uint16[10] pricePerAdjective;\n        uint256 pricePerLevel; // decimal factor 100000\n    }\n\n    uint256 public durabilityEffectDivider = 48;\n    uint256[10] public maxLevelPerRarity = [\n        10, 12, 15, 17, 20,\n        22, 25, 27, 30, 35\n    ];\n    uint16[5] public multiplierPerGrade = [1740, 1520, 1320, 1150, 1000];\n    Attributes public bltAttribute;\n    Attributes public maticAttribute;\n    Attributes public csAttribute;\n\n    constructor(\n        IBlastEquipmentNFT _blastEquipmentNFT,\n        IERC20 _blastToken,\n        ERC20Burnable _csToken,\n        address _treasuryAddress,\n        address _companyAddress\n    ) Utility(_blastEquipmentNFT, _blastToken, _csToken, _treasuryAddress, _companyAddress) {\n        uint16[10] memory _bltPricePerRarity = [\n            uint16(3), 4, 4, 5, 5,\n            6, 7, 7, 8, 9\n        ];\n        uint16[10] memory _bltPricePerAdjective = [\n            uint16(0), 0, 0, 1, 1,\n            2, 2, 3, 4, 4\n        ];\n        uint16[10] memory _maticPricePerRarity = [\n            uint16(30), 40, 40, 50, 50,\n            60, 70, 70, 80, 90\n        ];\n        uint16[10] memory _maticPricePerAdjective = [\n            uint16(0), 0, 0, 13, 13,\n            27, 27, 40, 53, 53\n        ];\n        uint16[10] memory _csPricePerRarity = [\n            100, 144, 207, 297, 427,\n            613, 881, 1266, 1819, 2613\n        ];\n        uint16[10] memory _csPricePerAdjective = [\n            0, 20, 50, 80, 80,\n            180, 180, 330, 480, 480\n        ];\n\n        bltAttribute = Attributes({\n            pricePerRarity: _bltPricePerRarity,\n            pricePerAdjective: _bltPricePerAdjective,\n            pricePerLevel: 500\n        });\n        maticAttribute = Attributes({\n            pricePerRarity: _maticPricePerRarity, // DECIMAL 100\n            pricePerAdjective: _maticPricePerAdjective, // DECIMAL 100\n            pricePerLevel: 500\n        });\n        csAttribute = Attributes({\n            pricePerRarity: _csPricePerRarity,\n            pricePerAdjective: _csPricePerAdjective,\n            pricePerLevel: 2500\n        });\n    }\n\n    function setDurabilityEffectDivider(uint256 _newValue) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_newValue > 0, Errors.NO_ZERO_VALUE);\n        durabilityEffectDivider = _newValue;\n    }\n\n    function setMultiplierPerGrade(uint16[5] memory _multiplierPerGrade) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_multiplierPerGrade.length == 5, Errors.INVALID_PARAM);\n        for (uint8 i = 0; i < 5; i++) {\n            multiplierPerGrade[i] = _multiplierPerGrade[i];\n        }\n    }\n\n    function upgrade(uint256 _tokenId, uint256 _increaseLevel) external nonReentrant whenNotPaused {\n        require(!isUsingMatic, Errors.USING_MATIC_NOW);\n        require(_msgSender() == blastEquipmentNFT.ownerOf(_tokenId), Errors.NOT_OWNER);\n\n        uint256 bltPrice = getMultipleRequiredPrice(0, _tokenId, _increaseLevel);\n        uint256 csPrice = getMultipleRequiredPrice(1, _tokenId, _increaseLevel);\n        (, , , , uint8 rarity, ) = blastEquipmentNFT.getStaticAttributes(_tokenId);\n        (uint256 level, , , , ,) = blastEquipmentNFT.getAttributes(_tokenId);\n        require(level != 0, Errors.INVALID_PARAM);\n        require(level != maxLevelPerRarity[rarity], Errors.MAX_LEVEL_REACHED);\n        require(bltPrice != 0 && csPrice != 0, Errors.INVALID_PARAM);\n\n        csToken.burnFrom(_msgSender(), csPrice);\n        blastToken.safeTransferFrom(\n            _msgSender(),\n            treasuryAddress,\n            bltPrice / 4\n        );\n        blastToken.safeTransferFrom(\n            _msgSender(),\n            companyAddress,\n            (bltPrice * 3) / 4\n        );\n\n        blastEquipmentNFT.setLevel(_tokenId, level + _increaseLevel);\n\n        emit LevelUpgraded(_tokenId, _msgSender(), level + _increaseLevel);\n    }\n\n    function upgradeUsingMatic(uint256 _tokenId, uint256 _increaseLevel) external payable nonReentrant whenNotPaused {\n        require(isUsingMatic, Errors.NOT_USING_MATIC_NOW);\n        require(_msgSender() == blastEquipmentNFT.ownerOf(_tokenId), Errors.NOT_OWNER);\n\n        uint256 bltPrice = getMultipleRequiredPrice(0, _tokenId, _increaseLevel);\n        uint256 csPrice = getMultipleRequiredPrice(1, _tokenId, _increaseLevel);\n        (, , , , uint8 rarity, ) = blastEquipmentNFT.getStaticAttributes(_tokenId);\n        (uint256 level, , , , ,) = blastEquipmentNFT.getAttributes(_tokenId);\n        require(level != 0, Errors.INVALID_PARAM);\n        require(level != maxLevelPerRarity[rarity], Errors.MAX_LEVEL_REACHED);\n        require(bltPrice != 0 && csPrice != 0, Errors.INVALID_PARAM);\n\n        csToken.burnFrom(_msgSender(), csPrice);\n        require(msg.value == bltPrice, Errors.INVALID_AMOUNT);\n        (bool sent1, ) = payable(treasuryAddress).call{value: bltPrice / 4}(\"\");\n        require(sent1, Errors.FAILED_TO_SEND_ETHER_TREASURY);\n        (bool sent2, ) = payable(companyAddress).call{value: (bltPrice * 3) / 4}(\"\");\n        require(sent2, Errors.FAILED_TO_SEND_ETHER_COMPANY);\n\n        blastEquipmentNFT.setLevel(_tokenId, level + _increaseLevel);\n\n        emit LevelUpgraded(_tokenId, _msgSender(), level + _increaseLevel);\n    }\n\n    function getPrice(uint8 _tokenType, uint8 maxDurability, uint8 adjective, uint8 rarity, uint8 grade, uint256 level) internal view returns (uint256) {\n        if (_tokenType == 0) {\n            if (isUsingMatic) {\n                return (maticAttribute.pricePerRarity[rarity] + maticAttribute.pricePerAdjective[adjective]) * (100000 + (level - 1) * maticAttribute.pricePerLevel) * multiplierPerGrade[grade] * 10 ** 10 / 100 * maxDurability / durabilityEffectDivider;\n            }\n            return (bltAttribute.pricePerRarity[rarity] + bltAttribute.pricePerAdjective[adjective]) * (100000 + (level - 1) * bltAttribute.pricePerLevel) * multiplierPerGrade[grade] * 10 ** 10 * maxDurability / durabilityEffectDivider;\n        } else if (_tokenType == 1) {\n            return (csAttribute.pricePerRarity[rarity] + csAttribute.pricePerAdjective[adjective]) * (100000 + (level - 1) * csAttribute.pricePerLevel) * multiplierPerGrade[grade] / DECIMAL_FACTOR / DECIMAL_FACTOR / 100 * 10 ** 18 * maxDurability / durabilityEffectDivider;\n        } else {\n            return 0;\n        }\n    }\n\n    function getMultipleRequiredPrice(uint8 _tokenType, uint256 _tokenId, uint256 _increaseLevel) public view returns (uint256) {\n        (, uint8 maxDurability, ,uint8 adjective, uint8 rarity, uint8 grade) = blastEquipmentNFT.getStaticAttributes(_tokenId);\n        (uint256 level, , , , ,) = blastEquipmentNFT.getAttributes(_tokenId);\n\n        uint256 totalPrice;\n        for (uint256 i = 0; i < _increaseLevel; i++) {\n            totalPrice += getPrice(_tokenType, maxDurability, adjective, rarity, grade, level + i);\n        }\n\n        return totalPrice;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IBlastEquipmentNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nstruct StaticAttributes {\n    uint8 maxLevel;\n    uint8 maxDurability;\n    uint8 maxReplication;\n    uint8 adjective;\n    uint8 rarity;\n    uint8 grade;\n}\n\n/**\n * @dev required interface of an Equipment NFT.\n */\ninterface IBlastEquipmentNFT is IERC721 {\n    /// @notice Event Attribute Updated\n    event AttributeUpdated(\n        uint256 tokenId,\n        uint256 level,\n        uint256 durabilityRestored,\n        uint256 durability,\n        uint256 lastRepairTime,\n        uint256 repairCount,\n        uint256 replicationCount\n    );\n\n    /// @notice Event Revealed TokenURI\n    event PermanentURI(string _value, uint256 indexed _id);\n\n    function safeMintReplicator(address _to, bytes32 _hash, string calldata _realUri, StaticAttributes calldata _staticAttribute) external returns (uint);\n\n    function revealRealTokenURI(uint _tokenId) external;\n\n    function setRealTokenURI(uint _tokenId, string calldata _realUri) external;\n\n    function setLevel(uint256 _tokenId, uint256 _newLevel) external;\n\n    function setRepairCount(uint256 _tokenId, uint256 _newRepairCount) external;\n\n    function setReplicationCount(uint256 _tokenId, uint256 _newReplicationCount)\n        external;\n\n    function scrap(uint256 _tokenId) external;\n\n    function getAttributes(uint256 _tokenId) external view returns (uint256, uint256, uint256, uint256, uint256, uint256);\n\n    function getStaticAttributes(uint256 _tokenId) external view returns (uint8, uint8, uint8, uint8, uint8, uint8);\n}\n"
    },
    "contracts/Utilities/Utility.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./../interfaces/IBlastEquipmentNFT.sol\";\nimport { Errors } from \"./../libraries/Errors.sol\";\n\nabstract contract Utility is AccessControl, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant DECIMAL_FACTOR = 1000;\n\n    IBlastEquipmentNFT public blastEquipmentNFT;\n    IERC20 public blastToken;\n    ERC20Burnable public csToken;\n\n    address internal treasuryAddress;\n    address internal companyAddress;\n    bool public isUsingMatic;\n\n    constructor(\n        IBlastEquipmentNFT _blastEquipmentNFT,\n        IERC20 _blastToken,\n        ERC20Burnable _csToken,\n        address _treasuryAddress,\n        address _companyAddress\n    ) {\n        require(\n            address(_blastEquipmentNFT) != address(0) &&\n            address(_blastToken) != address(0) &&\n            address(_csToken) != address(0) &&\n            _treasuryAddress != address(0) &&\n            _companyAddress != address(0),\n            Errors.NO_ZERO_ADDRESS\n        );\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        blastEquipmentNFT = _blastEquipmentNFT;\n        blastToken = _blastToken;\n        csToken = _csToken;\n        treasuryAddress = _treasuryAddress;\n        companyAddress = _companyAddress;\n    }\n\n    function setTreasuryAddress(address _treasury)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_treasury != address(0), Errors.NO_ZERO_ADDRESS);\n        treasuryAddress = _treasury;\n    }\n\n    function setCompanyAddress(address _company)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_company != address(0), Errors.NO_ZERO_ADDRESS);\n        companyAddress = _company;\n    }\n\n    function setBlastEquipmentAddress(IBlastEquipmentNFT _blastEquipmentNFT)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(address(_blastEquipmentNFT) != address(0), Errors.NO_ZERO_ADDRESS);\n        blastEquipmentNFT = _blastEquipmentNFT;\n    }\n\n    function setBlastTokenAddress(IERC20 _blastToken)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(address(_blastToken) != address(0), Errors.NO_ZERO_ADDRESS);\n        blastToken = _blastToken;\n    }\n\n    function setCSTokenAddress(ERC20Burnable _csToken)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(address(_csToken) != address(0), Errors.NO_ZERO_ADDRESS);\n        csToken = _csToken;\n    }\n\n    function flipIsUsingMatic() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        isUsingMatic = !isUsingMatic;\n    }    \n    \n    // @notice Pauses/Unpauses the contract\n    // @dev While paused, addListing, and buy are not allowed\n    // @param stop whether to pause or unpause the contract.\n    function pause(bool stop) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (stop) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/Utilities/Replicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./../interfaces/IBlastEquipmentNFT.sol\";\nimport \"./Utility.sol\";\n\ncontract Replicator is Utility {\n    using SafeERC20 for IERC20;\n\n    struct Parent {\n        uint256 parent0;\n        uint256 parent1;\n    }\n\n    mapping(address => uint256) public nonces;\n    uint256 public replicationTimer = 5 minutes;\n\n    event Replicated(\n        uint256 parent0,\n        uint256 parent1,\n        uint256 childId,\n        address owner,\n        uint256 timestamp\n    );\n    event Morphed(\n        uint256 parent0,\n        uint256 parent1,\n        uint256 childId,\n        address owner,\n        uint256 timestamp\n    );\n\n    // Child Token ID : Parent Struct\n    mapping(uint256 => Parent) public parents;\n    // Child Token ID : morphTime\n    mapping(uint256 => uint256) public morphTimestamp;\n    // Parent Token ID : isReplicating\n    mapping(uint256 => bool) public isReplicating;\n\n    uint256[7] public csPrices = [\n        1250e18, 1800e18, 3200e18, 5000e18,\n        9000e18, 14000e18, 22500e18\n    ];\n    uint256[7] public maticCsPrices = [\n        250e18, 350e18, 500e18, 700e18,\n        1000e18, 1500e18, 2000e18\n    ];\n    uint256[7] public bltPrices = [\n        7e18, 9e18, 12e18, 15e18,\n        20e18, 25e18, 30e18\n    ];\n\n    /// @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n    /// @param _blastEquipmentNFT : address of EquipmentNFT contract\n    /// @param _blastToken : address of Primary Token\n    /// @param _csToken : address of Secondary Token\n    constructor(\n        IBlastEquipmentNFT _blastEquipmentNFT,\n        IERC20 _blastToken,\n        ERC20Burnable _csToken,\n        address _treasuryAddress,\n        address _companyAddress\n    ) Utility(_blastEquipmentNFT, _blastToken, _csToken, _treasuryAddress, _companyAddress) {\n    }\n\n    function setCSPrices(uint256[] calldata _csPrices)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_csPrices.length == 7, Errors.INVALID_PARAM);\n        for (uint8 i = 0; i < 7; i++) {\n            csPrices[i] = _csPrices[i];\n        }\n    }\n\n    function setBLTPrices(uint256[] calldata _bltPrices)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_bltPrices.length == 7, Errors.INVALID_PARAM);\n        for (uint8 i = 0; i < 7; i++) {\n            bltPrices[i] = _bltPrices[i];\n        }\n    }\n\n    function setMaticCSPrices(uint256[] calldata _maticCsPrices)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_maticCsPrices.length == 7, Errors.INVALID_PARAM);\n        for (uint8 i = 0; i < 7; i++) {\n            maticCsPrices[i] = _maticCsPrices[i];\n        }\n    }\n\n    function replicate(\n        string calldata _hashString,\n        string calldata _realUri,\n        uint256 _p1,\n        uint256 _p2,\n        StaticAttributes calldata _staticAttribute\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant whenNotPaused {\n        require(_p1 != _p2, Errors.INVALID_PARAM);\n        address tokenOwner = blastEquipmentNFT.ownerOf(_p1);\n        require(tokenOwner == blastEquipmentNFT.ownerOf(_p2), Errors.INVALID_PARAM);\n        require(!isReplicating[_p1] && !isReplicating[_p2], Errors.NOT_READY_REPLICATE);\n\n        setReplicatorCount(_p1, _p2, tokenOwner);\n\n        uint childTokenId = mintChild(tokenOwner, _hashString, _realUri, _p1, _p2, _staticAttribute);\n\n        emit Replicated(_p1, _p2, childTokenId, tokenOwner, block.timestamp);\n    }\n\n    // Convert an hexadecimal character to their value\n    function fromHexChar(uint8 c) internal pure returns (uint8) {\n        if (bytes1(c) >= bytes1(\"0\") && bytes1(c) <= bytes1(\"9\")) {\n            return c - uint8(bytes1(\"0\"));\n        }\n        if (bytes1(c) >= bytes1(\"a\") && bytes1(c) <= bytes1(\"f\")) {\n            return 10 + c - uint8(bytes1(\"a\"));\n        }\n        if (bytes1(c) >= bytes1(\"A\") && bytes1(c) <= bytes1(\"F\")) {\n            return 10 + c - uint8(bytes1(\"A\"));\n        }\n        revert(Errors.INVALID_HEX_CHARACTER);\n    }\n\n    // Convert an hexadecimal string to raw bytes\n    function fromHex(string memory s) internal pure returns (bytes memory) {\n        bytes memory ss = bytes(s);\n        require(ss.length%2 == 0); // length must be even\n        bytes memory r = new bytes(ss.length/2);\n        for (uint i=0; i<ss.length/2; ++i) {\n            r[i] = bytes1(fromHexChar(uint8(ss[2*i])) * 16 +\n                        fromHexChar(uint8(ss[2*i+1])));\n        }\n        return r;\n    }\n\n    function setReplicatorCount(uint256 _p1, uint256 _p2, address tokenOwner) internal {\n        (, , , , , uint256 currentReplicationCountP1) = blastEquipmentNFT.getAttributes(_p1);\n        (, , , , , uint256 currentReplicationCountP2) = blastEquipmentNFT.getAttributes(_p2);\n        uint256 totalCSAmount = getTotalCSAmount(currentReplicationCountP1, currentReplicationCountP2);\n        csToken.burnFrom(tokenOwner, totalCSAmount);\n        if (!isUsingMatic) {\n            uint256 totalBltAmount = getTotalBLSTAmount(currentReplicationCountP1, currentReplicationCountP2);\n            blastToken.safeTransferFrom(\n                tokenOwner,\n                treasuryAddress,\n                totalBltAmount / 4\n            );\n            blastToken.safeTransferFrom(\n                tokenOwner,\n                companyAddress,\n                (totalBltAmount * 3) / 4\n            );\n        }\n        blastEquipmentNFT.setReplicationCount(\n            _p1,\n            currentReplicationCountP1 + 1\n        );\n        blastEquipmentNFT.setReplicationCount(\n            _p2,\n            currentReplicationCountP2 + 1\n        );\n    }\n\n    function mintChild(address tokenOwner, string calldata _hashString, string calldata _realUri, uint256 _p1, uint256 _p2, StaticAttributes calldata _staticAttribute) internal returns (uint256) {\n        uint256 childTokenId = blastEquipmentNFT.safeMintReplicator(\n            tokenOwner,\n            bytes32(fromHex(_hashString)),\n            _realUri,\n            _staticAttribute\n        );\n        isReplicating[childTokenId] = true;\n        parents[childTokenId] = Parent({parent0: _p1, parent1: _p2});\n        morphTimestamp[childTokenId] = block.timestamp + replicationTimer;\n\n        return childTokenId;\n    }\n\n    function morph(uint256 _childId) external nonReentrant whenNotPaused {\n        require(blastEquipmentNFT.ownerOf(_childId) == _msgSender(), Errors.NOT_OWNER);\n        require(morphTimestamp[_childId] != 0 && morphTimestamp[_childId] <= block.timestamp, Errors.NOT_READY_MORPH);\n\n        Parent memory _parent = parents[_childId];\n        isReplicating[_childId] = false;\n\n        blastEquipmentNFT.revealRealTokenURI(_childId);\n\n        emit Morphed(\n            _parent.parent0,\n            _parent.parent1,\n            _childId,\n            _msgSender(),\n            block.timestamp\n        );\n    }\n\n    function setReplicationTimer(uint _newTimer) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_newTimer > 0, Errors.NO_ZERO_VALUE);\n        replicationTimer = _newTimer;\n    }\n\n    function getTotalCSAmount(uint256 currentReplicationCountP1, uint256 currentReplicationCountP2) public view returns (uint256) {\n        if (isUsingMatic) {\n            return maticCsPrices[currentReplicationCountP1] + maticCsPrices[currentReplicationCountP2];\n        }\n        return csPrices[currentReplicationCountP1] + csPrices[currentReplicationCountP2];\n    }\n\n    function getTotalBLSTAmount(uint256 currentReplicationCountP1, uint256 currentReplicationCountP2) public view returns (uint256) {\n        return bltPrices[currentReplicationCountP1] + bltPrices[currentReplicationCountP2];\n    }\n}\n"
    },
    "contracts/Utilities/Scrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./../interfaces/IBlastEquipmentNFT.sol\";\nimport \"./../interfaces/ICraftSpiceToken.sol\";\nimport { Errors } from \"./../libraries/Errors.sol\";\n\ncontract Scrapper is AccessControl, ReentrancyGuard, Pausable {\n    IBlastEquipmentNFT public blastEquipmentNFT;\n    ICraftSpiceToken public csToken;\n\n    uint256 public constant DECIMAL_FACTOR = 1000;\n\n    uint256 public growthMultiplier = 1200;\n    uint256[10] public csValuePerRarity = [\n        100, 120, 144, 173, 208,\n        250, 300, 360, 432, 518\n    ];\n    uint256[10] public csAdditiveValuePerAdjective = [\n        20, 40, 70, 100, 100,\n        200, 200, 350, 500, 500\n    ];\n    uint256[5] public gradeMultiplierPerGrade = [\n        165, 140, 120, 110, 100 // DECIMAL FACTOR = 100\n    ];\n    uint256 public csPercentagePerLevel = 25;\n\n    event Scrapped(uint256 tokenId, address user, uint256 csAmount);\n\n    constructor (IBlastEquipmentNFT _blastEquipmentNFT, ICraftSpiceToken _csToken) {\n        require(address(_blastEquipmentNFT) != address(0) && address(_csToken) != address(0), Errors.NO_ZERO_ADDRESS);\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        blastEquipmentNFT = _blastEquipmentNFT;\n        csToken = _csToken;\n    }\n\n    function scrap(uint256 _tokenId) external nonReentrant whenNotPaused {\n        require(\n            blastEquipmentNFT.ownerOf(_tokenId) == _msgSender(),\n            Errors.NOT_OWNER\n        );\n        uint256 csAmount = getCSPrice(_tokenId);\n        csToken.mintFromScrap(_msgSender(), csAmount);\n        blastEquipmentNFT.scrap(_tokenId);\n\n        emit Scrapped(_tokenId, _msgSender(), csAmount);\n    }\n\n    function getCSPrice(uint256 _tokenId) public view returns (uint256) {\n        (, , , uint8 adjective, uint8 rarity, uint8 grade) = blastEquipmentNFT.getStaticAttributes(_tokenId);\n        (uint256 level, , , , ,) = blastEquipmentNFT.getAttributes(_tokenId);\n        return ((csValuePerRarity[rarity] + csAdditiveValuePerAdjective[adjective]) + (csValuePerRarity[rarity] + csAdditiveValuePerAdjective[adjective]) * (level - 1) * csPercentagePerLevel / 1000) * gradeMultiplierPerGrade[grade] / 100 * 10 ** 18;\n    }\n\n    function setBlastEquipmentAddress(IBlastEquipmentNFT _blastEquipmentNFT)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(address(_blastEquipmentNFT) != address(0), Errors.NO_ZERO_ADDRESS);\n        blastEquipmentNFT = _blastEquipmentNFT;\n    }\n\n    function setCSTokenAddress(ICraftSpiceToken _csToken)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(address(_csToken) != address(0), Errors.NO_ZERO_ADDRESS);\n        csToken = _csToken;\n    }\n\n    function setCSAdditiveValuePerAdjective(uint256[10] memory _csAdditiveValuePerAdjective)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_csAdditiveValuePerAdjective.length == 10, Errors.INVALID_PARAM);\n        for (uint8 i = 0; i < 10; i++) {\n            csAdditiveValuePerAdjective[i] = _csAdditiveValuePerAdjective[i];\n        }\n    }\n\n    function setCsValuePerRarity(uint256[10] memory _csValuePerRarity)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_csValuePerRarity.length == 10, Errors.INVALID_PARAM);\n        for (uint8 i = 0; i < 10; i++) {\n            csValuePerRarity[i] = _csValuePerRarity[i];\n        }\n    }\n\n    function setGradeMultiplierPerGrade(uint256[5] memory _gradeMultiplierPerGrade)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_gradeMultiplierPerGrade.length == 5, Errors.INVALID_PARAM);\n        for (uint8 i = 0; i < 10; i++) {\n            gradeMultiplierPerGrade[i] = _gradeMultiplierPerGrade[i];\n        }\n    }\n\n    // @notice Pauses/Unpauses the contract\n    // @dev While paused, addListing, and buy are not allowed\n    // @param stop whether to pause or unpause the contract.\n    function pause(bool stop) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (stop) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n}"
    },
    "contracts/interfaces/ICraftSpiceToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev interface of secondary token\n */\ninterface ICraftSpiceToken is IERC20 {\n    function mintFromScrap(address _to, uint256 _amount) external;\n}\n"
    },
    "contracts/SecondaryToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/ICraftSpiceToken.sol\";\nimport { Errors } from \"./libraries/Errors.sol\";\n\n/// @title Blast Royale Token - Secondary Token\n/// @dev Based on OpenZeppelin Contracts.\ncontract SecondaryToken is ERC20, ERC20Burnable, ICraftSpiceToken, ERC20Pausable, AccessControl, ReentrancyGuard {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    event Claimed(address user, uint256 amount);\n    event MintedFromScrap(address user, uint256 amount);\n\n    /// @notice Token constructor\n    /// @dev Creates the token and setup the initial supply and the Admin Role.\n    /// @param name Name of the Token\n    /// @param symbol Symbol of the token\n    /// @param _initialSupply Initial Supply\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 _initialSupply,\n        address _signer\n    ) ERC20(name, symbol) {\n        require(_signer != address(0));\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(MINTER_ROLE, _msgSender());\n        _mint(_msgSender(), _initialSupply);\n    }\n\n    /// @notice Mint new tokens\n    /// @param _to Target Address\n    /// @param _amount Token Amount\n    function claim(address _to, uint256 _amount)\n        external\n        onlyRole(MINTER_ROLE)\n    {\n        _mint(_to, _amount);\n\n        emit Claimed(_to, _amount);\n    }\n\n    /// @notice Mint new tokens\n    /// @param _to Target Address\n    /// @param _amount Token Amount\n    function mintFromScrap(address _to, uint256 _amount)\n        external\n        override\n        onlyRole(MINTER_ROLE)\n    {\n        _mint(_to, _amount);\n\n        emit MintedFromScrap(_to, _amount);\n    }\n\n    function pause(bool stop) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (stop) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /// @notice Verifications before Token Transfer\n    /// @param from Address from\n    /// @param from to Address from\n    /// @param amount tokens to be transferred\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "contracts/Utilities/ReplicatorSignature.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./../interfaces/IBlastEquipmentNFT.sol\";\n\nerror NotOwner();\nerror NotReadyMorph();\nerror NoZeroAddress();\nerror NotReadyReplicate();\nerror InvalidParams();\nerror InvalidSignature();\n\ncontract ReplicatorSignature is AccessControl, EIP712, ReentrancyGuard, Pausable {\n    using ECDSA for bytes32;\n    using SafeERC20 for IERC20;\n\n    struct Parent {\n        uint256 parent0;\n        uint256 parent1;\n    }\n\n    AggregatorV3Interface internal priceFeed;\n\n    bytes32 public constant REPLICATOR_TYPEHASH = keccak256(\"REPLICATOR(address sender,string uri,string hash,string realUri,uint256 p1,uint256 p2,uint256 nonce,uint256 deadline)\");\n    // Token related Addresses\n    IBlastEquipmentNFT public blastEquipmentNFT;\n    IERC20 public blastToken;\n    ERC20Burnable public csToken;\n\n    address private signer;\n    mapping(address => uint256) public nonces;\n    uint256 public constant REPLICATION_TIMER = 5 minutes;\n\n    event Replicated(\n        uint256 parent0,\n        uint256 parent1,\n        uint256 childId,\n        address owner,\n        uint256 timestamp\n    );\n    event Morphed(\n        uint256 parent0,\n        uint256 parent1,\n        uint256 childId,\n        address owner,\n        uint256 timestamp\n    );\n\n    address private treasuryAddress;\n    address private companyAddress;\n    bool public isUsingMatic;\n    // Child Token ID : Parent Struct\n    mapping(uint256 => Parent) public parents;\n    // Child Token ID : morphTime\n    mapping(uint256 => uint256) public morphTimestamp;\n    // Parent Token ID : isReplicating\n    mapping(uint256 => bool) public isReplicating;\n\n    uint256[7] public csPrices = [\n        1250e18,\n        1800e18,\n        3200e18,\n        5000e18,\n        9000e18,\n        14000e18,\n        22500e18\n    ];\n    uint256[7] public bltPrices = [\n        7e18,\n        9e18,\n        12e18,\n        15e18,\n        20e18,\n        25e18,\n        30e18\n    ];\n\n    /// @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n    /// @param _blastEquipmentNFT : address of EquipmentNFT contract\n    /// @param _blastToken : address of Primary Token\n    /// @param _csToken : address of Secondary Token\n    constructor(\n        IBlastEquipmentNFT _blastEquipmentNFT,\n        IERC20 _blastToken,\n        ERC20Burnable _csToken,\n        address _treasuryAddress,\n        address _companyAddress,\n        address _signer\n    ) EIP712(\"REPLICATOR\", \"1.0.0\") {\n        if (\n            address(_blastEquipmentNFT) == address(0) ||\n            address(_blastToken) == address(0) ||\n            address(_csToken) == address(0) ||\n            _treasuryAddress == address(0) ||\n            _companyAddress == address(0) ||\n            _signer == address(0)\n        ) revert NoZeroAddress();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        blastEquipmentNFT = _blastEquipmentNFT;\n        blastToken = _blastToken;\n        csToken = _csToken;\n        treasuryAddress = _treasuryAddress;\n        companyAddress = _companyAddress;\n        signer = _signer;\n\n        priceFeed = AggregatorV3Interface(0xd0D5e3DB44DE05E9F294BB0a3bEEaF030DE24Ada);\n    }\n\n    function setTreasuryAddress(address _treasury)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        if (_treasury == address(0)) revert NoZeroAddress();\n        treasuryAddress = _treasury;\n    }\n\n    function setCompanyAddress(address _company)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        if (_company == address(0)) revert NoZeroAddress();\n        companyAddress = _company;\n    }\n\n    function setCSPrices(uint256[] calldata _csPrices)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        if (_csPrices.length != 7) revert InvalidParams();\n        for (uint8 i = 0; i < 7; i++) {\n            csPrices[i] = _csPrices[i];\n        }\n    }\n\n    function setBLTPrices(uint256[] calldata _bltPrices)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        if (_bltPrices.length != 7) revert InvalidParams();\n        for (uint8 i = 0; i < 7; i++) {\n            bltPrices[i] = _bltPrices[i];\n        }\n    }\n\n    function setBlastEquipmentAddress(IBlastEquipmentNFT _blastEquipmentNFT)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(address(_blastEquipmentNFT) != address(0), \"NoZeroAddress\");\n        blastEquipmentNFT = _blastEquipmentNFT;\n    }\n\n    function setBlastTokenAddress(IERC20 _blastToken)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(address(_blastToken) != address(0), \"NoZeroAddress\");\n        blastToken = _blastToken;\n    }\n\n    function setCSTokenAddress(ERC20Burnable _csToken)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(address(_csToken) != address(0), \"NoZeroAddress\");\n        csToken = _csToken;\n    }\n\n    function toggleIsUsingMatic() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        isUsingMatic = !isUsingMatic;\n    }\n\n    function replicate(\n        string calldata _uri,\n        string calldata _hashString,\n        string calldata _realUri,\n        uint256 _p1,\n        uint256 _p2,\n        uint256 _deadline,\n        bytes calldata _signature,\n        StaticAttributes calldata _staticAttribute\n    ) external payable nonReentrant whenNotPaused {\n        if (_p1 == _p2) revert InvalidParams();\n        if (blastEquipmentNFT.ownerOf(_p1) != blastEquipmentNFT.ownerOf(_p2)) revert InvalidParams();\n        if (blastEquipmentNFT.ownerOf(_p1) != _msgSender()) revert InvalidParams();\n\n        if (isReplicating[_p1] || isReplicating[_p2])\n            revert NotReadyReplicate();\n\n        if (block.timestamp >= _deadline) revert InvalidParams();\n\n        require(_verify(_hashFunc(_msgSender(), _uri, _hashString, _realUri, _p1, _p2, nonces[_msgSender()], _deadline), _signature), \"Replicator:Invalid Signature\");\n        nonces[_msgSender()] ++;\n\n        setReplicatorCount(_p1, _p2, blastEquipmentNFT.ownerOf(_p1));\n\n        uint childTokenId = mintChild(blastEquipmentNFT.ownerOf(_p1), _hashString, _realUri, _p1, _p2, _staticAttribute);\n\n        emit Replicated(_p1, _p2, childTokenId, blastEquipmentNFT.ownerOf(_p1), block.timestamp);\n    }\n\n    // Convert an hexadecimal character to their value\n    function fromHexChar(uint8 c) internal pure returns (uint8) {\n        if (bytes1(c) >= bytes1(\"0\") && bytes1(c) <= bytes1(\"9\")) {\n            return c - uint8(bytes1(\"0\"));\n        }\n        if (bytes1(c) >= bytes1(\"a\") && bytes1(c) <= bytes1(\"f\")) {\n            return 10 + c - uint8(bytes1(\"a\"));\n        }\n        if (bytes1(c) >= bytes1(\"A\") && bytes1(c) <= bytes1(\"F\")) {\n            return 10 + c - uint8(bytes1(\"A\"));\n        }\n        revert(\"fail\");\n    }\n\n    // Convert an hexadecimal string to raw bytes\n    function fromHex(string memory s) internal pure returns (bytes memory) {\n        bytes memory ss = bytes(s);\n        require(ss.length%2 == 0); // length must be even\n        bytes memory r = new bytes(ss.length/2);\n        for (uint i=0; i<ss.length/2; ++i) {\n            r[i] = bytes1(fromHexChar(uint8(ss[2*i])) * 16 +\n                        fromHexChar(uint8(ss[2*i+1])));\n        }\n        return r;\n    }\n\n    function setReplicatorCount(uint256 _p1, uint256 _p2, address tokenOwner) internal {\n        uint256 currentReplicationCountP1;\n        uint256 currentReplicationCountP2;\n        (, , , , , currentReplicationCountP1) = blastEquipmentNFT.getAttributes(_p1);\n        (, , , , , currentReplicationCountP2) = blastEquipmentNFT.getAttributes(_p2);\n        csToken.burnFrom(\n            tokenOwner,\n            csPrices[currentReplicationCountP1] +\n                csPrices[currentReplicationCountP2]\n        );\n        uint256 totalBltAmount = bltPrices[currentReplicationCountP1] +\n            bltPrices[currentReplicationCountP2];\n        if (isUsingMatic) {\n            require(msg.value == totalBltAmount, \"Replicator:Invalid Matic Amount\");\n            (bool sent1, ) = payable(treasuryAddress).call{value: totalBltAmount / 4}(\"\");\n            require(sent1, \"Failed to send treasuryAddress\");\n            (bool sent2, ) = payable(companyAddress).call{value: (totalBltAmount * 3) / 4}(\"\");\n            require(sent2, \"Failed to send companyAddress\");\n        } else {\n            require(msg.value == 0, \"Replicator:Invalid Value\");\n            blastToken.safeTransferFrom(\n                tokenOwner,\n                treasuryAddress,\n                totalBltAmount / 4\n            );\n            blastToken.safeTransferFrom(\n                tokenOwner,\n                companyAddress,\n                (totalBltAmount * 3) / 4\n            );\n        }\n        blastEquipmentNFT.setReplicationCount(\n            _p1,\n            currentReplicationCountP1 + 1\n        );\n        blastEquipmentNFT.setReplicationCount(\n            _p2,\n            currentReplicationCountP2 + 1\n        );\n    }\n\n    function mintChild(address tokenOwner, string calldata _hashString, string calldata _realUri, uint256 _p1, uint256 _p2, StaticAttributes calldata _staticAttribute) internal returns (uint256) {\n        uint256 childTokenId = blastEquipmentNFT.safeMintReplicator(\n            tokenOwner,\n            bytes32(fromHex(_hashString)),\n            _realUri,\n            _staticAttribute\n        );\n        isReplicating[childTokenId] = true;\n        parents[childTokenId] = Parent({parent0: _p1, parent1: _p2});\n        morphTimestamp[childTokenId] = block.timestamp + REPLICATION_TIMER;\n\n        return childTokenId;\n    }\n\n    function _verify(bytes32 digest, bytes memory signature) internal view returns (bool)\n    {\n        return ECDSA.recover(digest, signature) == signer;\n    }\n\n    function _hashFunc(\n        address _sender,\n        string calldata _uri,\n        string calldata _hash,\n        string calldata _realUri,\n        uint256 _p1,\n        uint256 _p2,\n        uint256 nonce,\n        uint256 deadline\n    ) internal view returns (bytes32)\n    {\n        return _hashTypedDataV4(keccak256(abi.encode(\n            REPLICATOR_TYPEHASH,\n            _sender,\n            keccak256(abi.encodePacked(_uri)),\n            keccak256(abi.encodePacked(_hash)),\n            keccak256(abi.encodePacked(_realUri)),\n            _p1,\n            _p2,\n            nonce,\n            deadline\n        )));\n    }\n\n    function morph(uint256 _childId) external nonReentrant whenNotPaused {\n        if (blastEquipmentNFT.ownerOf(_childId) != _msgSender())\n            revert NotOwner();\n        if (morphTimestamp[_childId] > block.timestamp) revert NotReadyMorph();\n\n        Parent memory _parent = parents[_childId];\n        isReplicating[_childId] = false;\n\n        blastEquipmentNFT.revealRealTokenURI(_childId);\n\n        emit Morphed(\n            _parent.parent0,\n            _parent.parent1,\n            _childId,\n            _msgSender(),\n            block.timestamp\n        );\n    }\n\n    /**\n     * Returns the latest price\n     */\n    function getLatestPrice() public view returns (int) {\n        (\n            /*uint80 roundID*/,\n            int price,\n            /*uint startedAt*/,\n            /*uint timeStamp*/,\n            /*uint80 answeredInRound*/\n        ) = priceFeed.latestRoundData();\n        return price;\n    }\n\n    // @notice Pauses/Unpauses the contract\n    // @dev While paused, addListing, and buy are not allowed\n    // @param stop whether to pause or unpause the contract.\n    function pause(bool stop) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (stop) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\n// EIP-712 is Final as of 2022-08-11. This file is deprecated.\n\nimport \"./EIP712.sol\";\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../Address.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        if (error == ECDSA.RecoverError.NoError && recovered == signer) {\n            return true;\n        }\n\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length == 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/RentableNFT.sol": {
      "content": "pragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"./IERC4907.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\n\ncontract RentableNFT is ERC721, IERC4907, Ownable, AccessControl {\n    using Strings for uint256;\n\n    uint256 private totalSupply;\n    mapping(uint256 => uint256) public rentalPrices;\n    mapping(uint256 => uint64) public rentalLengths;\n    mapping(uint256 => uint64) public rentalStarts;\n    mapping(uint256 => bool) public rentalAvailabilities;\n    string private baseURI;\n\n    struct UserInfo {\n        address user; // address of user role\n        uint64 expires; // unix timestamp, user expires\n    }\n    mapping(uint256 => UserInfo) internal _users;\n\n    constructor(string memory _baseURI) ERC721(\"RentableNFT\", \"RNFT\") {\n        baseURI = _baseURI;\n    }\n\n    function mint(address to) external onlyOwner {\n        require(totalSupply < 888, \"Maximum token supply reached\");\n\n        totalSupply++;\n        _safeMint(to, totalSupply);\n    }\n\n    function setRentalDetails(\n        uint256 tokenId,\n        uint256 price,\n        uint64 rentalLength\n    ) external {\n        require(\n            msg.sender == ownerOf(tokenId),\n            \"Only the token owner can set the rental details\"\n        );\n        require(\n            rentalStarts[tokenId] == 0,\n            \"Can only set rental details when token is not rented out\"\n        );\n        rentalPrices[tokenId] = price;\n        rentalLengths[tokenId] = rentalLength;\n    }\n\n    function setAvailableForRent(\n        uint256 tokenId,\n        bool rentalAvailability\n    ) external {\n        require(\n            msg.sender == ownerOf(tokenId),\n            \"Only the token owner can set the rental details\"\n        );\n        rentalAvailabilities[tokenId] = rentalAvailability;\n    }\n\n    function endRental(uint256 tokenId) external {\n        require(\n            msg.sender == ownerOf(tokenId),\n            \"Only the token owner can end the rental\"\n        );\n        require(rentalStarts[tokenId] > 0, \"Rental has not started\");\n        require(\n            block.timestamp >= this.userExpires(tokenId),\n            \"Rental time is not over yet\"\n        );\n\n        (bool sent, ) = payable(ownerOf(tokenId)).call{\n            value: rentalPrices[tokenId]\n        }(\"\");\n        require(sent, \"Fail to send MATIC to the NFT owner\");\n\n        setUser(tokenId, address(0), 0);\n        rentalStarts[tokenId] = 0;\n    }\n\n    function rentalInfo(\n        uint256 tokenId\n    ) external view returns (uint256, uint256, uint256, bool, uint64) {\n        return (\n            rentalPrices[tokenId],\n            rentalLengths[tokenId],\n            rentalStarts[tokenId],\n            rentalAvailabilities[tokenId],\n            uint64(block.timestamp)\n        );\n    }\n\n    function rent(uint256 tokenId) external payable {\n        require(rentalPrices[tokenId] > 0, \"Rental price not set\");\n        require(rentalStarts[tokenId] == 0, \"Token already rented\");\n        require(rentalAvailabilities[tokenId] == true, \"Not available to rent\");\n\n        uint256 rentalPrice = rentalPrices[tokenId];\n        require(msg.value == rentalPrice, \"Incorrect rental price\");\n\n        rentalStarts[tokenId] = uint64(block.timestamp);\n        setUser(\n            tokenId,\n            msg.sender,\n            rentalStarts[tokenId] + rentalLengths[tokenId]\n        );\n    }\n\n    /// @notice Set BaseURI for token metadata URI\n    /// @dev The caller must have the `DEFAULT_ADMIN_ROLE`.\n    function setBaseURI(\n        string memory _baseURI\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        baseURI = _baseURI;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControl, ERC721) returns (bool) {\n        return\n            interfaceId == type(IERC4907).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function getUri(\n        uint256 tokenId\n    ) public view virtual returns (string memory) {\n        require(_exists(tokenId), \"URI query for nonexistent token\");\n\n        return string(abi.encodePacked(baseURI, tokenId.toString()));\n    }\n\n    /// @notice set the user and expires of a NFT\n    /// @dev The zero address indicates there is no user\n    /// Throws if `tokenId` is not valid NFT\n    /// @param user  The new user of the NFT\n    /// @param expires  UNIX timestamp, The new user could use the NFT before expires\n    function setUser(\n        uint256 tokenId,\n        address user,\n        uint64 expires\n    ) public virtual {\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n        UserInfo storage info = _users[tokenId];\n        info.user = user;\n        info.expires = expires;\n        emit UpdateUser(tokenId, user, expires);\n    }\n\n    /// @notice Get the user address of an NFT\n    /// @dev The zero address indicates that there is no user or the user is expired\n    /// @param tokenId The NFT to get the user address for\n    /// @return The user address for this NFT\n    function userOf(uint256 tokenId) public view virtual returns (address) {\n        if (uint256(_users[tokenId].expires) >= block.timestamp) {\n            return _users[tokenId].user;\n        } else {\n            return address(0);\n        }\n    }\n\n    /// @notice Get the user expires of an NFT\n    /// @dev The zero value indicates that there is no user\n    /// @param tokenId The NFT to get the user expires for\n    /// @return The user expires for this NFT\n    function userExpires(\n        uint256 tokenId\n    ) public view virtual returns (uint256) {\n        return _users[tokenId].expires;\n    }\n}\n"
    },
    "contracts/IERC4907.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity ^0.8.9;\n\ninterface IERC4907 {\n    // Logged when the user of a token assigns a new user or updates expires\n    /// @notice Emitted when the `user` of an NFT or the `expires` of the `user` is changed\n    /// The zero address for user indicates that there is no user address\n    event UpdateUser(\n        uint256 indexed tokenId,\n        address indexed user,\n        uint64 expires\n    );\n\n    /// @notice set the user and expires of a NFT\n    /// @dev The zero address indicates there is no user\n    /// Throws if `tokenId` is not valid NFT\n    /// @param user  The new user of the NFT\n    /// @param expires  UNIX timestamp, The new user could use the NFT before expires\n    function setUser(uint256 tokenId, address user, uint64 expires) external;\n\n    /// @notice Get the user address of an NFT\n    /// @dev The zero address indicates that there is no user or the user is expired\n    /// @param tokenId The NFT to get the user address for\n    /// @return The user address for this NFT\n    function userOf(uint256 tokenId) external view returns (address);\n\n    /// @notice Get the user expires of an NFT\n    /// @dev The zero value indicates that there is no user\n    /// @param tokenId The NFT to get the user expires for\n    /// @return The user expires for this NFT\n    function userExpires(uint256 tokenId) external view returns (uint256);\n}\n"
    },
    "contracts/BlastLootBox.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./interfaces/IBlastLootbox.sol\";\nimport \"./interfaces/IBlastEquipmentNFT.sol\";\nimport { Errors } from \"./libraries/Errors.sol\";\n\n/// @title Blast LootBox NFT\n/// @dev BlastLootBox ERC721 token\ncontract BlastLootBox is\n    IBlastLootbox,\n    ERC721,\n    ERC721URIStorage,\n    ERC721Holder,\n    Pausable,\n    AccessControl\n{\n    using Counters for Counters.Counter;\n\n    struct LootBox {\n        uint256 token0;\n        uint256 token1;\n        uint256 token2;\n    }\n\n    bytes32 public constant GAME_ROLE = keccak256(\"GAME_ROLE\");\n\n    Counters.Counter public _tokenIdCounter;\n    mapping(uint256 => LootBox) private lootboxDetails;\n    mapping(uint256 => uint8) private tokenTypes;\n    IBlastEquipmentNFT public blastEquipmentNFT;\n    bool public openAvailable;\n\n    /// @param name Name of the contract\n    /// @param symbol Symbol of the contract\n    constructor(\n        string memory name,\n        string memory symbol,\n        IBlastEquipmentNFT _blastEquipmentNFT\n    ) ERC721(name, symbol) {\n        require(address(_blastEquipmentNFT) != address(0), Errors.NO_ZERO_ADDRESS);\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(GAME_ROLE, _msgSender());\n        blastEquipmentNFT = _blastEquipmentNFT;\n    }\n\n    /// @notice Creates a new token for `_to`. Its token ID will be automatically\n    /// @dev The caller must have the `DEFAULT_ADMIN_ROLE`.\n    /// _tokenType should be 1 or 2 (In case of 1, it's normal box. In case of 2, it's gw box)\n    function safeMint(\n        address[] calldata _to,\n        string[] calldata _uri,\n        LootBox[] calldata _eqtIds,\n        uint8 _tokenType\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_to.length == _uri.length && _to.length == _eqtIds.length, Errors.INVALID_PARAM);\n        require(_tokenType == 1 || _tokenType == 2, Errors.INVALID_PARAM);\n\n        for (uint256 i = 0; i < _to.length; i++) {\n            uint256 tokenId = _tokenIdCounter.current();\n            _tokenIdCounter.increment();\n            lootboxDetails[tokenId] = _eqtIds[i];\n            tokenTypes[tokenId] = _tokenType;\n            _mint(_to[i], tokenId);\n            _setTokenURI(tokenId, _uri[i]);\n        }\n    }\n\n    function open(uint256 _tokenId) external {\n        require(_exists(_tokenId), Errors.NOT_EXIST_TOKEN_ID);\n        require(_msgSender() == ownerOf(_tokenId), Errors.NOT_OWNER);\n        require(openAvailable, Errors.NOT_AVAILABLE_TO_OPEN);\n\n        _open(_tokenId, _msgSender());\n    }\n\n    function openTo(uint256 _tokenId, address _to)\n        external\n        onlyRole(GAME_ROLE)\n    {\n        require(_exists(_tokenId), Errors.NOT_EXIST_TOKEN_ID);\n        require(_to == ownerOf(_tokenId), Errors.NOT_OWNER);\n        require(openAvailable, Errors.NOT_AVAILABLE_TO_OPEN);\n\n        _open(_tokenId, _to);\n    }\n\n    function _open(uint256 _tokenId, address _to) internal {\n        LootBox memory _eqtIds = lootboxDetails[_tokenId];\n\n        blastEquipmentNFT.transferFrom(address(this), _to, _eqtIds.token0);\n        blastEquipmentNFT.transferFrom(address(this), _to, _eqtIds.token1);\n        blastEquipmentNFT.transferFrom(address(this), _to, _eqtIds.token2);\n\n        blastEquipmentNFT.revealRealTokenURI(_eqtIds.token0);\n        blastEquipmentNFT.revealRealTokenURI(_eqtIds.token1);\n        blastEquipmentNFT.revealRealTokenURI(_eqtIds.token2);\n\n        emit Open(_tokenId, _eqtIds.token0, _eqtIds.token1, _eqtIds.token2);\n        _burn(_tokenId);\n    }\n\n    /// @notice Get Token Type. (GWB or NB)\n    /// @dev Returned value should be 1 or 2\n    /// @param _tokenId Token ID.\n    function getTokenType(uint256 _tokenId)\n        external\n        view\n        override\n        returns (uint8)\n    {\n        return tokenTypes[_tokenId];\n    }\n\n    function setOpenAvailableStatus(bool _status)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        openAvailable = _status;\n    }\n\n    /// @notice Unpauses all token transfers.\n    /// @dev The caller must be the Owner (or have approval) of the Token.\n    /// @param tokenId Token ID.\n    function _burn(uint256 tokenId)\n        internal\n        override(ERC721, ERC721URIStorage)\n    {\n        super._burn(tokenId);\n    }\n\n    /// @notice Returns the TokenURI.\n    /// @param tokenId Token ID.\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721, ERC721URIStorage)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    // @notice Pauses/Unpauses the contract\n    // @dev While paused, actions are not allowed\n    // @param stop whether to pause or unpause the contract.\n    function pause(bool stop) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (stop) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override whenNotPaused {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    /// @dev See {IERC165-supportsInterface}.\n    /// @param interfaceId Interface ID.\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControl, IERC165, ERC721)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev See {ERC721-_burn}. This override additionally checks to see if a\n     * token-specific URI was set for the token, and if so, it deletes the token URI from\n     * the storage mapping.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/interfaces/IBlastLootbox.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/**\n * @dev required interface of an Lootbox NFT.\n */\ninterface IBlastLootbox is IERC721 {\n    event Open(uint lootboxId, uint token0, uint token1, uint token2);\n\n    function getTokenType(uint _tokenId) external view returns (uint8);\n}\n"
    },
    "contracts/MarketplaceLootbox.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"./interfaces/IBlastLootbox.sol\";\nimport { Errors } from \"./libraries/Errors.sol\";\n\nstruct Listing {\n    address owner;\n    bool isActive;\n    uint256 tokenId;\n    uint256 price;\n    IERC20 tokenAddress;\n}\n\nstruct PurchaseLimit {\n    uint256 gwbLimit;\n    uint256 nbLimit;\n}\n\n/// @title Marketplace contract to trade Lootbox\n/// @dev Based on OpenZeppelin Contracts.\ncontract MarketplaceLootbox is ReentrancyGuard, Ownable, Pausable {\n    using SafeERC20 for IERC20;\n\n    bytes32 public merkleRoot;\n    bytes32 public luckyMerkleRoot;\n\n    PurchaseLimit private whitelistLimit;\n    PurchaseLimit private luckyUserLimit;\n    uint256 public activeListingCount;\n\n    mapping(address => bool) public whitelistedTokens;\n    mapping(uint256 => Listing) public listings;\n    // user => tokenType => count\n    mapping(address => mapping(uint8 => uint256)) private boughtCount;\n    IBlastLootbox private lootboxContract;\n\n    /// @notice Event Listed\n    event LootboxListed(\n        uint256 tokenId,\n        address seller,\n        uint256 price,\n        address payTokenAddress\n    );\n\n    /// @notice Event Delisted\n    event LootboxDelisted(uint256 tokenId, address seller);\n\n    /// @notice EventItem Sold\n    event LootboxSold(\n        uint256 tokenId,\n        address seller,\n        address buyer,\n        uint256 price,\n        bool whitelisted,\n        bool isLucky\n    );\n\n    event WhitelistAdded(address[] whitelists);\n\n    event WhitelistRemoved(address[] whitelists);\n\n    /// @notice Token constructor\n    /// @dev Setup the blastlootbox contract\n    /// @param lootboxAddress Address of the NFT Contract.\n    constructor(\n        IBlastLootbox lootboxAddress,\n        bytes32 _merkleRoot,\n        bytes32 _luckyMerkleRoot\n    ) {\n        require(address(lootboxAddress) != address(0), Errors.NO_ZERO_ADDRESS);\n        lootboxContract = lootboxAddress;\n        merkleRoot = _merkleRoot;\n        luckyMerkleRoot = _luckyMerkleRoot;\n\n        whitelistLimit = PurchaseLimit({gwbLimit: 0, nbLimit: 1});\n        luckyUserLimit = PurchaseLimit({gwbLimit: 1, nbLimit: 0});\n    }\n\n    /// @notice add a Listing to the Marketplace\n    /// @dev Creates a new entry for a Listing object and transfers the Token to the contract\n    /// @param tokenIds NFT TokenId.\n    /// @param price Price in NFTs.\n    function addListing(\n        uint256[] memory tokenIds,\n        uint256 price,\n        IERC20 payTokenAddress\n    ) public onlyOwner nonReentrant whenNotPaused {\n        require(price != 0, Errors.NO_ZERO_VALUE);\n        if (address(payTokenAddress) != address(0)) {\n            require(\n                whitelistedTokens[address(payTokenAddress)],\n                Errors.TOKEN_NOT_WHITELISTED\n            );\n        }\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(!listings[tokenIds[i]].isActive, Errors.LISTING_IS_NOT_ACTIVED);\n        }\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            listings[tokenId] = Listing({\n                owner: _msgSender(),\n                isActive: true,\n                tokenId: tokenId,\n                price: price,\n                tokenAddress: payTokenAddress\n            });\n            activeListingCount = activeListingCount + 1;\n            lootboxContract.transferFrom(_msgSender(), address(this), tokenId);\n\n            emit LootboxListed(\n                tokenId,\n                _msgSender(),\n                price,\n                address(payTokenAddress)\n            );\n        }\n    }\n\n    /// @notice Remove a Listing from the Marketplace\n    /// @dev Marks Listing as not active object and transfers the Token back\n    /// @param tokenId NFT Token Id.\n    function removeListing(uint256 tokenId)\n        public\n        onlyOwner\n        nonReentrant\n        whenNotPaused\n    {\n        Listing storage listing = listings[tokenId];\n        require(listing.owner == _msgSender(), Errors.NOT_OWNER);\n        require(listing.isActive, Errors.LISTING_IS_NOT_ACTIVED);\n        listing.isActive = false;\n        lootboxContract.transferFrom(address(this), _msgSender(), tokenId);\n        activeListingCount = activeListingCount - 1;\n        emit LootboxDelisted(listing.tokenId, _msgSender());\n    }\n\n    /// @notice Buys a listed NFT\n    /// @dev Transfers both the ERC20 token (price) and the NFT.\n    /// @param _tokenId NFT Token Id.\n    /// @param _merkleProof MerkleProof value\n    function buy(uint256 _tokenId, bytes32[] calldata _merkleProof)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        uint8 tokenType = lootboxContract.getTokenType(_tokenId);\n        require(tokenType != 0, Errors.INVALID_PARAM);\n        require(listings[_tokenId].isActive, Errors.LISTING_IS_NOT_ACTIVED);\n\n        bool userWhitelisted = MerkleProof.verify(\n            _merkleProof,\n            merkleRoot,\n            keccak256(abi.encodePacked(_msgSender()))\n        );\n        bool isLuckyUser = MerkleProof.verify(\n            _merkleProof,\n            luckyMerkleRoot,\n            keccak256(abi.encodePacked(_msgSender()))\n        );\n\n        require(userWhitelisted || isLuckyUser, Errors.INVALID_MERKLE_PROOF);\n        if (userWhitelisted) {\n            require(boughtCount[_msgSender()][tokenType] < getLimit(tokenType, true), Errors.MAX_LIMIT_REACHED);\n        } else if (isLuckyUser) {\n            require(boughtCount[_msgSender()][tokenType] < getLimit(tokenType, false), Errors.MAX_LIMIT_REACHED);\n        }\n\n        boughtCount[_msgSender()][tokenType] += 1;\n        listings[_tokenId].isActive = false;\n        IERC20 payTokenAddress = listings[_tokenId].tokenAddress;\n\n        if (address(payTokenAddress) == address(0)) {\n            require(msg.value == listings[_tokenId].price, Errors.INVALID_AMOUNT);\n            (bool sent, ) = payable(listings[_tokenId].owner).call{\n                value: msg.value\n            }(\"\");\n            require(sent, Errors.FAILED_TO_SEND_ETHER_USER);\n        } else {\n            require(msg.value == 0, Errors.INVALID_AMOUNT);\n            payTokenAddress.safeTransferFrom(\n                _msgSender(),\n                listings[_tokenId].owner,\n                listings[_tokenId].price\n            );\n        }\n        lootboxContract.transferFrom(address(this), _msgSender(), _tokenId);\n\n        activeListingCount = activeListingCount - 1;\n\n        emit LootboxSold(\n            listings[_tokenId].tokenId,\n            listings[_tokenId].owner,\n            _msgSender(),\n            listings[_tokenId].price,\n            userWhitelisted,\n            isLuckyUser\n        );\n    }\n\n    /// @notice Get purchased count\n    /// @dev This function will return purchased count with tokenType\n    /// @param _address owner Address\n    /// @param _tokenType Token Type (1 or 2), (1 is NB, 2 is GWB)\n    function getOwnedCount(address _address, uint8 _tokenType)\n        external\n        view\n        returns (uint256)\n    {\n        return boughtCount[_address][_tokenType];\n    }\n\n    /// @notice Get limitation value\n    /// @dev This function will return limit value whether whitelisted or not and tokenType\n    /// @param _tokenType Token Type (1 or 2), (1 is NB, 2 is GWB)\n    /// @param _whitelist Whitelist or not\n    function getLimit(uint256 _tokenType, bool _whitelist)\n        internal\n        view\n        returns (uint256)\n    {\n        if (_tokenType == 1) {\n            if (_whitelist) {\n                return whitelistLimit.nbLimit;\n            } else {\n                return luckyUserLimit.nbLimit;\n            }\n        } else if (_tokenType == 2) {\n            if (_whitelist) {\n                return whitelistLimit.gwbLimit;\n            } else {\n                return luckyUserLimit.gwbLimit;\n            }\n        }\n        return 0;\n    }\n\n    /// @notice Update MerkleRoot value\n    /// @dev This function will update merkleRoot\n    /// @param _merkleRoot root of merkle Tree\n    function updateMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n        merkleRoot = _merkleRoot;\n    }\n\n    /// @notice Update LuckyMerkleRoot value\n    /// @dev This function will update _luckyMerkleRoot\n    /// @param _luckyMerkleRoot root of merkle Tree\n    function updateLuckyMerkleRoot(bytes32 _luckyMerkleRoot)\n        external\n        onlyOwner\n    {\n        luckyMerkleRoot = _luckyMerkleRoot;\n    }\n\n    /// @notice Set the limitation for whitelist users\n    /// @dev This will set whitelist users limitation for GWB and NB\n    /// @param _limit gwbLimit & nbLimit\n    function setWhitelistPurchaseLimit(PurchaseLimit memory _limit)\n        external\n        onlyOwner\n    {\n        whitelistLimit = _limit;\n    }\n\n    /// @notice Set the limitation for whitelisted and lucky users\n    /// @dev This will set non-whitelist users limitation for GWB and NB\n    /// @param _limit gwbLimit & nbLimit\n    function setNotWhitelistPurchaseLimit(PurchaseLimit memory _limit)\n        external\n        onlyOwner\n    {\n        luckyUserLimit = _limit;\n    }\n\n    /// @notice Set whitelist tokens for paying\n    /// @dev This will create whitelisting of stable token for Lootbox trading\n    /// @param _whitelist whitelist erc20 token array\n    function setWhitelistTokens(address[] memory _whitelist)\n        external\n        onlyOwner\n    {\n        for (uint256 i = 0; i < _whitelist.length; i++) {\n            require(_whitelist[i] != address(0), Errors.NO_ZERO_ADDRESS);\n            whitelistedTokens[_whitelist[i]] = true;\n        }\n\n        emit WhitelistAdded(_whitelist);\n    }\n\n    /// @notice Remove whitelist tokens for paying\n    /// @dev This will remove whitelisting of stable token for Lootbox trading\n    /// @param _whitelist whitelist erc20 token array\n    function removeWhitelistTokens(address[] memory _whitelist)\n        external\n        onlyOwner\n    {\n        for (uint256 i = 0; i < _whitelist.length; i++) {\n            require(_whitelist[i] != address(0), Errors.NO_ZERO_ADDRESS);\n            whitelistedTokens[_whitelist[i]] = false;\n        }\n\n        emit WhitelistRemoved(_whitelist);\n    }\n\n    // @notice Pauses/Unpauses the contract\n    // @dev While paused, addListing, and buy are not allowed\n    // @param stop whether to pause or unpause the contract.\n    function pause(bool stop) external onlyOwner {\n        if (stop) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/RentableSpiceCorbos.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"erc721a/contracts/extensions/ERC721AQueryable.sol\";\nimport \"./IERC721M.sol\";\nimport \"./IERC4907.sol\";\n\n/**\n * @title ERC721M\n *\n * @dev ERC721A subclass with MagicEden launchpad features including\n *  - multiple minting stages with time-based auto stage switch\n *  - global and stage wallet-level minting limit\n *  - whitelist using merkle tree\n *  - crossmint support\n *  - anti-botting\n */\ncontract RentableSpiceCorbos is\n    IERC721M,\n    IERC4907,\n    ERC721AQueryable,\n    Ownable,\n    ReentrancyGuard\n{\n    using ECDSA for bytes32;\n\n    // Whether this contract is mintable.\n    bool private _mintable;\n\n    // Whether base URI is permanent. Once set, base URI is immutable.\n    bool private _baseURIPermanent;\n\n    // Specify how long a signature from cosigner is valid for, recommend 300 seconds.\n    uint64 private _timestampExpirySeconds;\n\n    // The address of the cosigner server.\n    address private _cosigner;\n\n    // The crossmint address. Need to set if using crossmint.\n    address private _crossmintAddress;\n\n    // The total mintable supply.\n    uint256 internal _maxMintableSupply;\n\n    // Global wallet limit, across all stages.\n    uint256 private _globalWalletLimit;\n\n    // Current base URI.\n    string private _currentBaseURI;\n\n    // The suffix for the token URL, e.g. \".json\".\n    string private _tokenURISuffix;\n\n    // Mint stage infomation. See MintStageInfo for details.\n    MintStageInfo[] private _mintStages;\n\n    // Minted count per stage per wallet.\n    mapping(uint256 => mapping(address => uint32))\n        private _stageMintedCountsPerWallet;\n\n    // Minted count per stage.\n    mapping(uint256 => uint256) private _stageMintedCounts;\n\n    struct UserInfo {\n        address user; // address of user role\n        uint64 expires; // unix timestamp, user expires\n    }\n    mapping(uint256 => UserInfo) internal _users;\n\n    constructor(\n        string memory collectionName,\n        string memory collectionSymbol,\n        string memory tokenURISuffix,\n        uint256 maxMintableSupply,\n        uint256 globalWalletLimit,\n        address cosigner,\n        uint64 timestampExpirySeconds\n    ) ERC721A(collectionName, collectionSymbol) {\n        if (globalWalletLimit > maxMintableSupply)\n            revert GlobalWalletLimitOverflow();\n\n        _mintable = false;\n        _maxMintableSupply = maxMintableSupply;\n        _globalWalletLimit = globalWalletLimit;\n        _tokenURISuffix = tokenURISuffix;\n        _cosigner = cosigner; // ethers.constants.AddressZero for no cosigning\n        _timestampExpirySeconds = timestampExpirySeconds;\n    }\n\n    /**\n     * @dev Returns whether mintable.\n     */\n    modifier canMint() {\n        if (!_mintable) revert NotMintable();\n        _;\n    }\n\n    /**\n     * @dev Returns whether NOT mintable.\n     */\n    modifier cannotMint() {\n        if (_mintable) revert Mintable();\n        _;\n    }\n\n    /**\n     * @dev Returns whether it has enough supply for the given qty.\n     */\n    modifier hasSupply(uint256 qty) {\n        if (totalSupply() + qty > _maxMintableSupply) revert NoSupplyLeft();\n        _;\n    }\n\n    /// @notice set the user and expires of a NFT\n    /// @dev The zero address indicates there is no user\n    /// Throws if `tokenId` is not valid NFT\n    /// @param user  The new user of the NFT\n    /// @param expires  UNIX timestamp, The new user could use the NFT before expires\n    function setUser(\n        uint256 tokenId,\n        address user,\n        uint64 expires\n    ) public virtual {\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n        UserInfo storage info = _users[tokenId];\n        info.user = user;\n        info.expires = expires;\n        emit UpdateUser(tokenId, user, expires);\n    }\n\n    /// @notice Get the user address of an NFT\n    /// @dev The zero address indicates that there is no user or the user is expired\n    /// @param tokenId The NFT to get the user address for\n    /// @return The user address for this NFT\n    function userOf(uint256 tokenId) public view virtual returns (address) {\n        if (uint256(_users[tokenId].expires) >= block.timestamp) {\n            return _users[tokenId].user;\n        } else {\n            return address(0);\n        }\n    }\n\n    /// @notice Get the user expires of an NFT\n    /// @dev The zero value indicates that there is no user\n    /// @param tokenId The NFT to get the user expires for\n    /// @return The user expires for this NFT\n    function userExpires(\n        uint256 tokenId\n    ) public view virtual returns (uint256) {\n        return _users[tokenId].expires;\n    }\n\n    /// @dev See {IERC165-supportsInterface}.\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC721A, IERC721A) returns (bool) {\n        return\n            interfaceId == type(IERC4907).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        super._beforeTokenTransfers(from, to, tokenId, 1);\n\n        if (from != to && _users[tokenId].user != address(0)) {\n            delete _users[tokenId];\n            emit UpdateUser(tokenId, address(0), 0);\n        }\n    }\n\n    /**\n     * @dev Returns cosigner address.\n     */\n    function getCosigner() external view override returns (address) {\n        return _cosigner;\n    }\n\n    /**\n     * @dev Returns cosign nonce.\n     */\n    function getCosignNonce(address minter) public view returns (uint256) {\n        return _numberMinted(minter);\n    }\n\n    /**\n     * @dev Sets cosigner.\n     */\n    function setCosigner(address cosigner) external onlyOwner {\n        _cosigner = cosigner;\n        emit SetCosigner(cosigner);\n    }\n\n    /**\n     * @dev Returns expiry in seconds.\n     */\n    function getTimestampExpirySeconds() public view override returns (uint64) {\n        return _timestampExpirySeconds;\n    }\n\n    /**\n     * @dev Sets expiry in seconds. This timestamp specifies how long a signature from cosigner is valid for.\n     */\n    function setTimestampExpirySeconds(uint64 expiry) external onlyOwner {\n        _timestampExpirySeconds = expiry;\n        emit SetTimestampExpirySeconds(expiry);\n    }\n\n    /**\n     * @dev Returns crossmint address.\n     */\n    function getCrossmintAddress() external view override returns (address) {\n        return _crossmintAddress;\n    }\n\n    /**\n     * @dev Sets crossmint address if using crossmint. This allows the specified address to call `crossmint`.\n     */\n    function setCrossmintAddress(address crossmintAddress) external onlyOwner {\n        _crossmintAddress = crossmintAddress;\n        emit SetCrossmintAddress(crossmintAddress);\n    }\n\n    /**\n     * @dev Sets stages in the format of an array of `MintStageInfo`.\n     *\n     * Following is an example of launch with two stages. The first stage is exclusive for whitelisted wallets\n     * specified by merkle root.\n     *    [{\n     *      price: 10000000000000000000,\n     *      maxStageSupply: 2000,\n     *      walletLimit: 1,\n     *      merkleRoot: 0x559fadeb887449800b7b320bf1e92d309f329b9641ac238bebdb74e15c0a5218,\n     *      startTimeUnixSeconds: 1667768000,\n     *      endTimeUnixSeconds: 1667771600,\n     *     },\n     *     {\n     *      price: 20000000000000000000,\n     *      maxStageSupply: 3000,\n     *      walletLimit: 2,\n     *      merkleRoot: 0,\n     *      startTimeUnixSeconds: 1667771600,\n     *      endTimeUnixSeconds: 1667775200,\n     *     }\n     * ]\n     */\n    function setStages(MintStageInfo[] calldata newStages) external onlyOwner {\n        uint256 originalSize = _mintStages.length;\n        for (uint256 i = 0; i < originalSize; i++) {\n            _mintStages.pop();\n        }\n\n        uint64 timestampExpirySeconds = getTimestampExpirySeconds();\n        for (uint256 i = 0; i < newStages.length; i++) {\n            if (i >= 1) {\n                if (\n                    newStages[i].startTimeUnixSeconds <\n                    newStages[i - 1].endTimeUnixSeconds + timestampExpirySeconds\n                ) {\n                    revert InsufficientStageTimeGap();\n                }\n            }\n            _assertValidStartAndEndTimestamp(\n                newStages[i].startTimeUnixSeconds,\n                newStages[i].endTimeUnixSeconds\n            );\n            _mintStages.push(\n                MintStageInfo({\n                    price: newStages[i].price,\n                    walletLimit: newStages[i].walletLimit,\n                    merkleRoot: newStages[i].merkleRoot,\n                    maxStageSupply: newStages[i].maxStageSupply,\n                    startTimeUnixSeconds: newStages[i].startTimeUnixSeconds,\n                    endTimeUnixSeconds: newStages[i].endTimeUnixSeconds\n                })\n            );\n            emit UpdateStage(\n                i,\n                newStages[i].price,\n                newStages[i].walletLimit,\n                newStages[i].merkleRoot,\n                newStages[i].maxStageSupply,\n                newStages[i].startTimeUnixSeconds,\n                newStages[i].endTimeUnixSeconds\n            );\n        }\n    }\n\n    /**\n     * @dev Gets whether mintable.\n     */\n    function getMintable() external view override returns (bool) {\n        return _mintable;\n    }\n\n    /**\n     * @dev Sets mintable.\n     */\n    function setMintable(bool mintable) external onlyOwner {\n        _mintable = mintable;\n        emit SetMintable(mintable);\n    }\n\n    /**\n     * @dev Returns number of stages.\n     */\n    function getNumberStages() external view override returns (uint256) {\n        return _mintStages.length;\n    }\n\n    /**\n     * @dev Returns maximum mintable supply.\n     */\n    function getMaxMintableSupply() external view override returns (uint256) {\n        return _maxMintableSupply;\n    }\n\n    /**\n     * @dev Sets maximum mintable supply.\n     *\n     * New supply cannot be larger than the old.\n     */\n    function setMaxMintableSupply(\n        uint256 maxMintableSupply\n    ) external virtual onlyOwner {\n        if (maxMintableSupply > _maxMintableSupply) {\n            revert CannotIncreaseMaxMintableSupply();\n        }\n        _maxMintableSupply = maxMintableSupply;\n        emit SetMaxMintableSupply(maxMintableSupply);\n    }\n\n    /**\n     * @dev Returns global wallet limit. This is the max number of tokens can be minted by one wallet.\n     */\n    function getGlobalWalletLimit() external view override returns (uint256) {\n        return _globalWalletLimit;\n    }\n\n    /**\n     * @dev Sets global wallet limit.\n     */\n    function setGlobalWalletLimit(\n        uint256 globalWalletLimit\n    ) external onlyOwner {\n        if (globalWalletLimit > _maxMintableSupply)\n            revert GlobalWalletLimitOverflow();\n        _globalWalletLimit = globalWalletLimit;\n        emit SetGlobalWalletLimit(globalWalletLimit);\n    }\n\n    /**\n     * @dev Returns number of minted token for a given address.\n     */\n    function totalMintedByAddress(\n        address a\n    ) external view virtual override returns (uint256) {\n        return _numberMinted(a);\n    }\n\n    /**\n     * @dev Returns info for one stage specified by index (starting from 0).\n     */\n    function getStageInfo(\n        uint256 index\n    ) external view override returns (MintStageInfo memory, uint32, uint256) {\n        if (index >= _mintStages.length) {\n            revert(\"InvalidStage\");\n        }\n        uint32 walletMinted = _stageMintedCountsPerWallet[index][msg.sender];\n        uint256 stageMinted = _stageMintedCounts[index];\n        return (_mintStages[index], walletMinted, stageMinted);\n    }\n\n    /**\n     * @dev Updates info for one stage specified by index (starting from 0).\n     */\n    function updateStage(\n        uint256 index,\n        uint80 price,\n        uint32 walletLimit,\n        bytes32 merkleRoot,\n        uint24 maxStageSupply,\n        uint64 startTimeUnixSeconds,\n        uint64 endTimeUnixSeconds\n    ) external onlyOwner {\n        if (index >= _mintStages.length) revert InvalidStage();\n        if (index >= 1) {\n            if (\n                startTimeUnixSeconds <\n                _mintStages[index - 1].endTimeUnixSeconds +\n                    getTimestampExpirySeconds()\n            ) {\n                revert InsufficientStageTimeGap();\n            }\n        }\n        _assertValidStartAndEndTimestamp(\n            startTimeUnixSeconds,\n            endTimeUnixSeconds\n        );\n        _mintStages[index].price = price;\n        _mintStages[index].walletLimit = walletLimit;\n        _mintStages[index].merkleRoot = merkleRoot;\n        _mintStages[index].maxStageSupply = maxStageSupply;\n        _mintStages[index].startTimeUnixSeconds = startTimeUnixSeconds;\n        _mintStages[index].endTimeUnixSeconds = endTimeUnixSeconds;\n\n        emit UpdateStage(\n            index,\n            price,\n            walletLimit,\n            merkleRoot,\n            maxStageSupply,\n            startTimeUnixSeconds,\n            endTimeUnixSeconds\n        );\n    }\n\n    /**\n     * @dev Mints token(s).\n     *\n     * qty - number of tokens to mint\n     * proof - the merkle proof generated on client side. This applies if using whitelist.\n     * timestamp - the current timestamp\n     * signature - the signature from cosigner if using cosigner.\n     */\n    function mint(\n        uint32 qty,\n        bytes32[] calldata proof,\n        uint64 timestamp,\n        bytes calldata signature\n    ) external payable nonReentrant {\n        _mintInternal(qty, msg.sender, proof, timestamp, signature);\n    }\n\n    /**\n     * @dev Mints token(s) through crossmint. This function is supposed to be called by crossmint.\n     *\n     * qty - number of tokens to mint\n     * to - the address to mint tokens to\n     * proof - the merkle proof generated on client side. This applies if using whitelist.\n     * timestamp - the current timestamp\n     * signature - the signature from cosigner if using cosigner.\n     */\n    function crossmint(\n        uint32 qty,\n        address to,\n        bytes32[] calldata proof,\n        uint64 timestamp,\n        bytes calldata signature\n    ) external payable nonReentrant {\n        if (_crossmintAddress == address(0)) revert CrossmintAddressNotSet();\n\n        // Check the caller is Crossmint\n        if (msg.sender != _crossmintAddress) revert CrossmintOnly();\n\n        _mintInternal(qty, to, proof, timestamp, signature);\n    }\n\n    /**\n     * @dev Implementation of minting.\n     */\n    function _mintInternal(\n        uint32 qty,\n        address to,\n        bytes32[] calldata proof,\n        uint64 timestamp,\n        bytes calldata signature\n    ) internal canMint hasSupply(qty) {\n        uint64 stageTimestamp = uint64(block.timestamp);\n\n        MintStageInfo memory stage;\n        if (_cosigner != address(0)) {\n            assertValidCosign(msg.sender, qty, timestamp, signature);\n            _assertValidTimestamp(timestamp);\n            stageTimestamp = timestamp;\n        }\n\n        uint256 activeStage = getActiveStageFromTimestamp(stageTimestamp);\n\n        stage = _mintStages[activeStage];\n\n        // Check value\n        if (msg.value < stage.price * qty) revert NotEnoughValue();\n\n        // Check stage supply if applicable\n        if (stage.maxStageSupply > 0) {\n            if (_stageMintedCounts[activeStage] + qty > stage.maxStageSupply)\n                revert StageSupplyExceeded();\n        }\n\n        // Check global wallet limit if applicable\n        if (_globalWalletLimit > 0) {\n            if (_numberMinted(to) + qty > _globalWalletLimit)\n                revert WalletGlobalLimitExceeded();\n        }\n\n        // Check wallet limit for stage if applicable, limit == 0 means no limit enforced\n        if (stage.walletLimit > 0) {\n            if (\n                _stageMintedCountsPerWallet[activeStage][to] + qty >\n                stage.walletLimit\n            ) revert WalletStageLimitExceeded();\n        }\n\n        // Check merkle proof if applicable, merkleRoot == 0x00...00 means no proof required\n        if (stage.merkleRoot != 0) {\n            if (\n                MerkleProof.processProof(\n                    proof,\n                    keccak256(abi.encodePacked(to))\n                ) != stage.merkleRoot\n            ) revert InvalidProof();\n        }\n\n        _stageMintedCountsPerWallet[activeStage][to] += qty;\n        _stageMintedCounts[activeStage] += qty;\n        _safeMint(to, qty);\n    }\n\n    /**\n     * @dev Mints token(s) by owner.\n     *\n     * NOTE: This function bypasses validations thus only available for owner.\n     * This is typically used for owner to  pre-mint or mint the remaining of the supply.\n     */\n    function ownerMint(\n        uint32 qty,\n        address to\n    ) external onlyOwner hasSupply(qty) {\n        _safeMint(to, qty);\n    }\n\n    /**\n     * @dev Withdraws funds by owner.\n     */\n    function withdraw() external onlyOwner {\n        uint256 value = address(this).balance;\n        (bool success, ) = msg.sender.call{value: value}(\"\");\n        if (!success) revert WithdrawFailed();\n        emit Withdraw(value);\n    }\n\n    /**\n     * @dev Sets token base URI.\n     */\n    function setBaseURI(string calldata baseURI) external onlyOwner {\n        if (_baseURIPermanent) revert CannotUpdatePermanentBaseURI();\n        _currentBaseURI = baseURI;\n        emit SetBaseURI(baseURI);\n    }\n\n    /**\n     * @dev Sets token base URI permanent. Cannot revert.\n     */\n    function setBaseURIPermanent() external onlyOwner {\n        _baseURIPermanent = true;\n        emit PermanentBaseURI(_currentBaseURI);\n    }\n\n    /**\n     * @dev Returns token URI suffix.\n     */\n    function getTokenURISuffix()\n        external\n        view\n        override\n        returns (string memory)\n    {\n        return _tokenURISuffix;\n    }\n\n    /**\n     * @dev Sets token URI suffix. e.g. \".json\".\n     */\n    function setTokenURISuffix(string calldata suffix) external onlyOwner {\n        _tokenURISuffix = suffix;\n    }\n\n    /**\n     * @dev Returns token URI for a given token id.\n     */\n    function tokenURI(\n        uint256 tokenId\n    ) public view override(ERC721A, IERC721A) returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _currentBaseURI;\n        return\n            bytes(baseURI).length != 0\n                ? string(\n                    abi.encodePacked(\n                        baseURI,\n                        _toString(tokenId),\n                        _tokenURISuffix\n                    )\n                )\n                : \"\";\n    }\n\n    /**\n     * @dev Returns data hash for the given minter, qty and timestamp.\n     */\n    function getCosignDigest(\n        address minter,\n        uint32 qty,\n        uint64 timestamp\n    ) public view returns (bytes32) {\n        if (_cosigner == address(0)) revert CosignerNotSet();\n        return\n            keccak256(\n                abi.encodePacked(\n                    address(this),\n                    minter,\n                    qty,\n                    _cosigner,\n                    timestamp,\n                    _chainID(),\n                    getCosignNonce(minter)\n                )\n            ).toEthSignedMessageHash();\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view virtual returns (bool) {\n        address owner = this.ownerOf(tokenId);\n        return (isApprovedForAll(owner, spender) ||\n            getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Validates the the given signature.\n     */\n    function assertValidCosign(\n        address minter,\n        uint32 qty,\n        uint64 timestamp,\n        bytes memory signature\n    ) public view override {\n        if (\n            !SignatureChecker.isValidSignatureNow(\n                _cosigner,\n                getCosignDigest(minter, qty, timestamp),\n                signature\n            )\n        ) revert InvalidCosignSignature();\n    }\n\n    /**\n     * @dev Returns the current active stage based on timestamp.\n     */\n    function getActiveStageFromTimestamp(\n        uint64 timestamp\n    ) public view override returns (uint256) {\n        for (uint256 i = 0; i < _mintStages.length; i++) {\n            if (\n                timestamp >= _mintStages[i].startTimeUnixSeconds &&\n                timestamp < _mintStages[i].endTimeUnixSeconds\n            ) {\n                return i;\n            }\n        }\n        revert InvalidStage();\n    }\n\n    /**\n     * @dev Validates the timestamp is not expired.\n     */\n    function _assertValidTimestamp(uint64 timestamp) internal view {\n        if (timestamp < block.timestamp - getTimestampExpirySeconds())\n            revert TimestampExpired();\n    }\n\n    /**\n     * @dev Validates the start timestamp is before end timestamp. Used when updating stages.\n     */\n    function _assertValidStartAndEndTimestamp(\n        uint64 start,\n        uint64 end\n    ) internal pure {\n        if (start >= end) revert InvalidStartAndEndTimestamp();\n    }\n\n    /**\n     * @dev Returns chain id.\n     */\n    function _chainID() private view returns (uint256) {\n        uint256 chainID;\n        assembly {\n            chainID := chainid()\n        }\n        return chainID;\n    }\n}\n"
    },
    "erc721a/contracts/extensions/ERC721AQueryable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport './IERC721AQueryable.sol';\nimport '../ERC721A.sol';\n\n/**\n * @title ERC721AQueryable.\n *\n * @dev ERC721A subclass with convenience query functions.\n */\nabstract contract ERC721AQueryable is ERC721A, IERC721AQueryable {\n    /**\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\n     *\n     * If the `tokenId` is out of bounds:\n     *\n     * - `addr = address(0)`\n     * - `startTimestamp = 0`\n     * - `burned = false`\n     * - `extraData = 0`\n     *\n     * If the `tokenId` is burned:\n     *\n     * - `addr = <Address of owner before token was burned>`\n     * - `startTimestamp = <Timestamp when token was burned>`\n     * - `burned = true`\n     * - `extraData = <Extra data when token was burned>`\n     *\n     * Otherwise:\n     *\n     * - `addr = <Address of owner>`\n     * - `startTimestamp = <Timestamp of start of ownership>`\n     * - `burned = false`\n     * - `extraData = <Extra data at start of ownership>`\n     */\n    function explicitOwnershipOf(uint256 tokenId) public view virtual override returns (TokenOwnership memory) {\n        TokenOwnership memory ownership;\n        if (tokenId < _startTokenId() || tokenId >= _nextTokenId()) {\n            return ownership;\n        }\n        ownership = _ownershipAt(tokenId);\n        if (ownership.burned) {\n            return ownership;\n        }\n        return _ownershipOf(tokenId);\n    }\n\n    /**\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\n     * See {ERC721AQueryable-explicitOwnershipOf}\n     */\n    function explicitOwnershipsOf(uint256[] calldata tokenIds)\n        external\n        view\n        virtual\n        override\n        returns (TokenOwnership[] memory)\n    {\n        unchecked {\n            uint256 tokenIdsLength = tokenIds.length;\n            TokenOwnership[] memory ownerships = new TokenOwnership[](tokenIdsLength);\n            for (uint256 i; i != tokenIdsLength; ++i) {\n                ownerships[i] = explicitOwnershipOf(tokenIds[i]);\n            }\n            return ownerships;\n        }\n    }\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`,\n     * in the range [`start`, `stop`)\n     * (i.e. `start <= tokenId < stop`).\n     *\n     * This function allows for tokens to be queried if the collection\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\n     *\n     * Requirements:\n     *\n     * - `start < stop`\n     */\n    function tokensOfOwnerIn(\n        address owner,\n        uint256 start,\n        uint256 stop\n    ) external view virtual override returns (uint256[] memory) {\n        unchecked {\n            if (start >= stop) revert InvalidQueryRange();\n            uint256 tokenIdsIdx;\n            uint256 stopLimit = _nextTokenId();\n            // Set `start = max(start, _startTokenId())`.\n            if (start < _startTokenId()) {\n                start = _startTokenId();\n            }\n            // Set `stop = min(stop, stopLimit)`.\n            if (stop > stopLimit) {\n                stop = stopLimit;\n            }\n            uint256 tokenIdsMaxLength = balanceOf(owner);\n            // Set `tokenIdsMaxLength = min(balanceOf(owner), stop - start)`,\n            // to cater for cases where `balanceOf(owner)` is too big.\n            if (start < stop) {\n                uint256 rangeLength = stop - start;\n                if (rangeLength < tokenIdsMaxLength) {\n                    tokenIdsMaxLength = rangeLength;\n                }\n            } else {\n                tokenIdsMaxLength = 0;\n            }\n            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);\n            if (tokenIdsMaxLength == 0) {\n                return tokenIds;\n            }\n            // We need to call `explicitOwnershipOf(start)`,\n            // because the slot at `start` may not be initialized.\n            TokenOwnership memory ownership = explicitOwnershipOf(start);\n            address currOwnershipAddr;\n            // If the starting slot exists (i.e. not burned), initialize `currOwnershipAddr`.\n            // `ownership.address` will not be zero, as `start` is clamped to the valid token ID range.\n            if (!ownership.burned) {\n                currOwnershipAddr = ownership.addr;\n            }\n            for (uint256 i = start; i != stop && tokenIdsIdx != tokenIdsMaxLength; ++i) {\n                ownership = _ownershipAt(i);\n                if (ownership.burned) {\n                    continue;\n                }\n                if (ownership.addr != address(0)) {\n                    currOwnershipAddr = ownership.addr;\n                }\n                if (currOwnershipAddr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            // Downsize the array to fit.\n            assembly {\n                mstore(tokenIds, tokenIdsIdx)\n            }\n            return tokenIds;\n        }\n    }\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`.\n     *\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\n     * It is meant to be called off-chain.\n     *\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\n     * multiple smaller scans if the collection is large enough to cause\n     * an out-of-gas error (10K collections should be fine).\n     */\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\n        unchecked {\n            uint256 tokenIdsIdx;\n            address currOwnershipAddr;\n            uint256 tokenIdsLength = balanceOf(owner);\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\n            TokenOwnership memory ownership;\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\n                ownership = _ownershipAt(i);\n                if (ownership.burned) {\n                    continue;\n                }\n                if (ownership.addr != address(0)) {\n                    currOwnershipAddr = ownership.addr;\n                }\n                if (currOwnershipAddr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            return tokenIds;\n        }\n    }\n}\n"
    },
    "contracts/IERC721M.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"erc721a/contracts/extensions/IERC721AQueryable.sol\";\n\ninterface IERC721M is IERC721AQueryable {\n    error CannotIncreaseMaxMintableSupply();\n    error CannotUpdatePermanentBaseURI();\n    error CosignerNotSet();\n    error CrossmintAddressNotSet();\n    error CrossmintOnly();\n    error GlobalWalletLimitOverflow();\n    error InsufficientStageTimeGap();\n    error InvalidCosignSignature();\n    error InvalidProof();\n    error InvalidStage();\n    error InvalidStageArgsLength();\n    error InvalidStartAndEndTimestamp();\n    error NoSupplyLeft();\n    error NotEnoughValue();\n    error NotMintable();\n    error Mintable();\n    error StageSupplyExceeded();\n    error TimestampExpired();\n    error WalletGlobalLimitExceeded();\n    error WalletStageLimitExceeded();\n    error WithdrawFailed();\n\n    struct MintStageInfo {\n        uint80 price;\n        uint32 walletLimit; // 0 for unlimited\n        bytes32 merkleRoot; // 0x0 for no presale enforced\n        uint24 maxStageSupply; // 0 for unlimited\n        uint64 startTimeUnixSeconds;\n        uint64 endTimeUnixSeconds;\n    }\n\n    event UpdateStage(\n        uint256 stage,\n        uint80 price,\n        uint32 walletLimit,\n        bytes32 merkleRoot,\n        uint24 maxStageSupply,\n        uint64 startTimeUnixSeconds,\n        uint64 endTimeUnixSeconds\n    );\n\n    event SetCosigner(address cosigner);\n    event SetCrossmintAddress(address crossmintAddress);\n    event SetMintable(bool mintable);\n    event SetMaxMintableSupply(uint256 maxMintableSupply);\n    event SetGlobalWalletLimit(uint256 globalWalletLimit);\n    event SetActiveStage(uint256 activeStage);\n    event SetBaseURI(string baseURI);\n    event SetTimestampExpirySeconds(uint64 expiry);\n    event PermanentBaseURI(string baseURI);\n    event Withdraw(uint256 value);\n\n    function getCosigner() external view returns (address);\n\n    function getCrossmintAddress() external view returns (address);\n\n    function getNumberStages() external view returns (uint256);\n\n    function getGlobalWalletLimit() external view returns (uint256);\n\n    function getTimestampExpirySeconds() external view returns (uint64);\n\n    function getMaxMintableSupply() external view returns (uint256);\n\n    function getMintable() external view returns (bool);\n\n    function totalMintedByAddress(address a) external view returns (uint256);\n\n    function getTokenURISuffix() external view returns (string memory);\n\n    function getStageInfo(uint256 index)\n        external\n        view\n        returns (\n            MintStageInfo memory,\n            uint32,\n            uint256\n        );\n\n    function getActiveStageFromTimestamp(uint64 timestamp)\n        external\n        view\n        returns (uint256);\n\n    function assertValidCosign(\n        address minter,\n        uint32 qty,\n        uint64 timestamp,\n        bytes memory signature\n    ) external view;\n}\n"
    },
    "erc721a/contracts/extensions/IERC721AQueryable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport '../IERC721A.sol';\n\n/**\n * @dev Interface of ERC721AQueryable.\n */\ninterface IERC721AQueryable is IERC721A {\n    /**\n     * Invalid query range (`start` >= `stop`).\n     */\n    error InvalidQueryRange();\n\n    /**\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\n     *\n     * If the `tokenId` is out of bounds:\n     *\n     * - `addr = address(0)`\n     * - `startTimestamp = 0`\n     * - `burned = false`\n     * - `extraData = 0`\n     *\n     * If the `tokenId` is burned:\n     *\n     * - `addr = <Address of owner before token was burned>`\n     * - `startTimestamp = <Timestamp when token was burned>`\n     * - `burned = true`\n     * - `extraData = <Extra data when token was burned>`\n     *\n     * Otherwise:\n     *\n     * - `addr = <Address of owner>`\n     * - `startTimestamp = <Timestamp of start of ownership>`\n     * - `burned = false`\n     * - `extraData = <Extra data at start of ownership>`\n     */\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\n\n    /**\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\n     * See {ERC721AQueryable-explicitOwnershipOf}\n     */\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`,\n     * in the range [`start`, `stop`)\n     * (i.e. `start <= tokenId < stop`).\n     *\n     * This function allows for tokens to be queried if the collection\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\n     *\n     * Requirements:\n     *\n     * - `start < stop`\n     */\n    function tokensOfOwnerIn(\n        address owner,\n        uint256 start,\n        uint256 stop\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`.\n     *\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\n     * It is meant to be called off-chain.\n     *\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\n     * multiple smaller scans if the collection is large enough to cause\n     * an out-of-gas error (10K collections should be fine).\n     */\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\n}\n"
    },
    "erc721a/contracts/ERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport './IERC721A.sol';\n\n/**\n * @dev Interface of ERC721 token receiver.\n */\ninterface ERC721A__IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/**\n * @title ERC721A\n *\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\n * Non-Fungible Token Standard, including the Metadata extension.\n * Optimized for lower gas during batch mints.\n *\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\n * starting from `_startTokenId()`.\n *\n * Assumptions:\n *\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\n */\ncontract ERC721A is IERC721A {\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\n    struct TokenApprovalRef {\n        address value;\n    }\n\n    // =============================================================\n    //                           CONSTANTS\n    // =============================================================\n\n    // Mask of an entry in packed address data.\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\n\n    // The bit position of `numberMinted` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\n\n    // The bit position of `numberBurned` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\n\n    // The bit position of `aux` in packed address data.\n    uint256 private constant _BITPOS_AUX = 192;\n\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\n\n    // The bit position of `startTimestamp` in packed ownership.\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\n\n    // The bit mask of the `burned` bit in packed ownership.\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\n\n    // The bit position of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\n\n    // The bit mask of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\n\n    // The bit position of `extraData` in packed ownership.\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\n\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\n\n    // The mask of the lower 160 bits for addresses.\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\n\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\n    // This limit is to prevent overflows on the address data entries.\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\n    // is required to cause an overflow, which is unrealistic.\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\n\n    // The `Transfer` event signature is given by:\n    // `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    // =============================================================\n    //                            STORAGE\n    // =============================================================\n\n    // The next token ID to be minted.\n    uint256 private _currentIndex;\n\n    // The number of tokens burned.\n    uint256 private _burnCounter;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned.\n    // See {_packedOwnershipOf} implementation for details.\n    //\n    // Bits Layout:\n    // - [0..159]   `addr`\n    // - [160..223] `startTimestamp`\n    // - [224]      `burned`\n    // - [225]      `nextInitialized`\n    // - [232..255] `extraData`\n    mapping(uint256 => uint256) private _packedOwnerships;\n\n    // Mapping owner address to address data.\n    //\n    // Bits Layout:\n    // - [0..63]    `balance`\n    // - [64..127]  `numberMinted`\n    // - [128..191] `numberBurned`\n    // - [192..255] `aux`\n    mapping(address => uint256) private _packedAddressData;\n\n    // Mapping from token ID to approved address.\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // =============================================================\n    //                          CONSTRUCTOR\n    // =============================================================\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _currentIndex = _startTokenId();\n    }\n\n    // =============================================================\n    //                   TOKEN COUNTING OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the starting token ID.\n     * To change the starting token ID, please override this function.\n     */\n    function _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Returns the next token ID to be minted.\n     */\n    function _nextTokenId() internal view virtual returns (uint256) {\n        return _currentIndex;\n    }\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than `_currentIndex - _startTokenId()` times.\n        unchecked {\n            return _currentIndex - _burnCounter - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev Returns the total amount of tokens minted in the contract.\n     */\n    function _totalMinted() internal view virtual returns (uint256) {\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\n        // and it is initialized to `_startTokenId()`.\n        unchecked {\n            return _currentIndex - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev Returns the total number of tokens burned.\n     */\n    function _totalBurned() internal view virtual returns (uint256) {\n        return _burnCounter;\n    }\n\n    // =============================================================\n    //                    ADDRESS DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(address owner) internal view returns (uint256) {\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(address owner) internal view returns (uint256) {\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(address owner) internal view returns (uint64) {\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\n    }\n\n    /**\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(address owner, uint64 aux) internal virtual {\n        uint256 packed = _packedAddressData[owner];\n        uint256 auxCasted;\n        // Cast `aux` with assembly to avoid redundant masking.\n        assembly {\n            auxCasted := aux\n        }\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\n        _packedAddressData[owner] = packed;\n    }\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        // The interface IDs are constants representing the first 4 bytes\n        // of the XOR of all function selectors in the interface.\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\n    }\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, it can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return '';\n    }\n\n    // =============================================================\n    //                     OWNERSHIPS OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return address(uint160(_packedOwnershipOf(tokenId)));\n    }\n\n    /**\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around over time.\n     */\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\n     */\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\n        return _unpackedOwnership(_packedOwnerships[index]);\n    }\n\n    /**\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\n     */\n    function _initializeOwnershipAt(uint256 index) internal virtual {\n        if (_packedOwnerships[index] == 0) {\n            _packedOwnerships[index] = _packedOwnershipOf(index);\n        }\n    }\n\n    /**\n     * Returns the packed ownership data of `tokenId`.\n     */\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\n        uint256 curr = tokenId;\n\n        unchecked {\n            if (_startTokenId() <= curr)\n                if (curr < _currentIndex) {\n                    uint256 packed = _packedOwnerships[curr];\n                    // If not burned.\n                    if (packed & _BITMASK_BURNED == 0) {\n                        // Invariant:\n                        // There will always be an initialized ownership slot\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\n                        // before an unintialized ownership slot\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\n                        // Hence, `curr` will not underflow.\n                        //\n                        // We can directly compare the packed value.\n                        // If the address is zero, packed will be zero.\n                        while (packed == 0) {\n                            packed = _packedOwnerships[--curr];\n                        }\n                        return packed;\n                    }\n                }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\n     */\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\n        ownership.addr = address(uint160(packed));\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\n        ownership.burned = packed & _BITMASK_BURNED != 0;\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\n    }\n\n    /**\n     * @dev Packs ownership data into a single uint256.\n     */\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\n        assembly {\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            owner := and(owner, _BITMASK_ADDRESS)\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\n        }\n    }\n\n    /**\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\n     */\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\n        // For branchless setting of the `nextInitialized` flag.\n        assembly {\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\n        }\n    }\n\n    // =============================================================\n    //                      APPROVAL OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) public payable virtual override {\n        address owner = ownerOf(tokenId);\n\n        if (_msgSenderERC721A() != owner)\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\n                revert ApprovalCallerNotOwnerNorApproved();\n            }\n\n        _tokenApprovals[tokenId].value = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n        return _tokenApprovals[tokenId].value;\n    }\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted. See {_mint}.\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return\n            _startTokenId() <= tokenId &&\n            tokenId < _currentIndex && // If within bounds,\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\n    }\n\n    /**\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\n     */\n    function _isSenderApprovedOrOwner(\n        address approvedAddress,\n        address owner,\n        address msgSender\n    ) private pure returns (bool result) {\n        assembly {\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            owner := and(owner, _BITMASK_ADDRESS)\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\n            // `msgSender == owner || msgSender == approvedAddress`.\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\n        }\n    }\n\n    /**\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\n     */\n    function _getApprovedSlotAndAddress(uint256 tokenId)\n        private\n        view\n        returns (uint256 approvedAddressSlot, address approvedAddress)\n    {\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\n        assembly {\n            approvedAddressSlot := tokenApproval.slot\n            approvedAddress := sload(approvedAddressSlot)\n        }\n    }\n\n    // =============================================================\n    //                      TRANSFER OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual override {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\n\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n        // The nested ifs save around 20+ gas over a compound boolean condition.\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\n\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        assembly {\n            if approvedAddress {\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // We can directly increment and decrement the balances.\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\n\n            // Updates:\n            // - `address` to the next owner.\n            // - `startTimestamp` to the timestamp of transfering.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `true`.\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                to,\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != _currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public payable virtual override {\n        transferFrom(from, to, tokenId);\n        if (to.code.length != 0)\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\n                revert TransferToNonERC721ReceiverImplementer();\n            }\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token IDs\n     * are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * `startTokenId` - the first token ID to be transferred.\n     * `quantity` - the amount to be transferred.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token IDs\n     * have been transferred. This includes minting.\n     * And also called after one token has been burned.\n     *\n     * `startTokenId` - the first token ID to be transferred.\n     * `quantity` - the amount to be transferred.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\n     *\n     * `from` - Previous owner of the given token ID.\n     * `to` - Target address that will receive the token.\n     * `tokenId` - Token ID to be transferred.\n     * `_data` - Optional data to send along with the call.\n     *\n     * Returns whether the call correctly returned the expected magic value.\n     */\n    function _checkContractOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\n            bytes4 retval\n        ) {\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert TransferToNonERC721ReceiverImplementer();\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }\n\n    // =============================================================\n    //                        MINT OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event for each mint.\n     */\n    function _mint(address to, uint256 quantity) internal virtual {\n        uint256 startTokenId = _currentIndex;\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\n        // `tokenId` has a maximum limit of 2**256.\n        unchecked {\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the `balance` and `numberMinted`.\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\n\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            _packedOwnerships[startTokenId] = _packOwnershipData(\n                to,\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\n            );\n\n            uint256 toMasked;\n            uint256 end = startTokenId + quantity;\n\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\n            // The assembly, together with the surrounding Solidity code, have been\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\n            assembly {\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\n                toMasked := and(to, _BITMASK_ADDRESS)\n                // Emit the `Transfer` event.\n                log4(\n                    0, // Start of data (0, since no data).\n                    0, // End of data (0, since no data).\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\n                    0, // `address(0)`.\n                    toMasked, // `to`.\n                    startTokenId // `tokenId`.\n                )\n\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\n                // that overflows uint256 will make the loop run out of gas.\n                // The compiler will optimize the `iszero` away for performance.\n                for {\n                    let tokenId := add(startTokenId, 1)\n                } iszero(eq(tokenId, end)) {\n                    tokenId := add(tokenId, 1)\n                } {\n                    // Emit the `Transfer` event. Similar to above.\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\n                }\n            }\n            if (toMasked == 0) revert MintToZeroAddress();\n\n            _currentIndex = end;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * This function is intended for efficient minting only during contract creation.\n     *\n     * It emits only one {ConsecutiveTransfer} as defined in\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\n     * instead of a sequence of {Transfer} event(s).\n     *\n     * Calling this function outside of contract creation WILL make your contract\n     * non-compliant with the ERC721 standard.\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {ConsecutiveTransfer} event.\n     */\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\n        uint256 startTokenId = _currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\n        unchecked {\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the `balance` and `numberMinted`.\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\n\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            _packedOwnerships[startTokenId] = _packOwnershipData(\n                to,\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\n            );\n\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\n\n            _currentIndex = startTokenId + quantity;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\n     * - `quantity` must be greater than 0.\n     *\n     * See {_mint}.\n     *\n     * Emits a {Transfer} event for each mint.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, quantity);\n\n        unchecked {\n            if (to.code.length != 0) {\n                uint256 end = _currentIndex;\n                uint256 index = end - quantity;\n                do {\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\n                        revert TransferToNonERC721ReceiverImplementer();\n                    }\n                } while (index < end);\n                // Reentrancy protection.\n                if (_currentIndex != end) revert();\n            }\n        }\n    }\n\n    /**\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\n     */\n    function _safeMint(address to, uint256 quantity) internal virtual {\n        _safeMint(to, quantity, '');\n    }\n\n    // =============================================================\n    //                        BURN OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Equivalent to `_burn(tokenId, false)`.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        _burn(tokenId, false);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        address from = address(uint160(prevOwnershipPacked));\n\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n        if (approvalCheck) {\n            // The nested ifs save around 20+ gas over a compound boolean condition.\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\n        }\n\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        assembly {\n            if approvedAddress {\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // Updates:\n            // - `balance -= 1`.\n            // - `numberBurned += 1`.\n            //\n            // We can directly decrement the balance, and increment the number burned.\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\n\n            // Updates:\n            // - `address` to the last owner.\n            // - `startTimestamp` to the timestamp of burning.\n            // - `burned` to `true`.\n            // - `nextInitialized` to `true`.\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                from,\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != _currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, address(0), tokenId);\n        _afterTokenTransfers(from, address(0), tokenId, 1);\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked {\n            _burnCounter++;\n        }\n    }\n\n    // =============================================================\n    //                     EXTRA DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Directly sets the extra data for the ownership data `index`.\n     */\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\n        uint256 packed = _packedOwnerships[index];\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\n        uint256 extraDataCasted;\n        // Cast `extraData` with assembly to avoid redundant masking.\n        assembly {\n            extraDataCasted := extraData\n        }\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\n        _packedOwnerships[index] = packed;\n    }\n\n    /**\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\n     * Intended to be overridden by the cosumer contract.\n     *\n     * `previousExtraData` - the value of `extraData` before transfer.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _extraData(\n        address from,\n        address to,\n        uint24 previousExtraData\n    ) internal view virtual returns (uint24) {}\n\n    /**\n     * @dev Returns the next extra data for the packed ownership data.\n     * The returned result is shifted into position.\n     */\n    function _nextExtraData(\n        address from,\n        address to,\n        uint256 prevOwnershipPacked\n    ) private view returns (uint256) {\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\n    }\n\n    // =============================================================\n    //                       OTHER OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the message sender (defaults to `msg.sender`).\n     *\n     * If you are writing GSN compatible contracts, you need to override this function.\n     */\n    function _msgSenderERC721A() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    /**\n     * @dev Converts a uint256 to its ASCII string decimal representation.\n     */\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n            let m := add(mload(0x40), 0xa0)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 1)\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n}\n"
    },
    "erc721a/contracts/IERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of ERC721A.\n */\ninterface IERC721A {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the\n     * ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    /**\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\n     */\n    error MintERC2309QuantityExceedsLimit();\n\n    /**\n     * The `extraData` cannot be set on an unintialized ownership slot.\n     */\n    error OwnershipNotInitializedForExtraData();\n\n    // =============================================================\n    //                            STRUCTS\n    // =============================================================\n\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Stores the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n        uint24 extraData;\n    }\n\n    // =============================================================\n    //                         TOKEN COUNTERS\n    // =============================================================\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    // =============================================================\n    //                            IERC721\n    // =============================================================\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables\n     * (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\n     * checking first that contract recipients are aware of the ERC721 protocol\n     * to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move\n     * this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\n     * whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external payable;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    // =============================================================\n    //                           IERC2309\n    // =============================================================\n\n    /**\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\n     * (inclusive) is transferred from `from` to `to`, as defined in the\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\n     *\n     * See {_mintERC2309} for more details.\n     */\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\n}\n"
    },
    "contracts/PrimaryToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\n\n/// @title Blast Royale Token - $BLT\n/// @dev Based on OpenZeppelin Contracts.\ncontract PrimaryToken is ERC20, ERC20Pausable, Ownable {\n    /// @notice Token constructor\n    /// @dev Creates the token and setup the initial supply and the Admin Role.\n    /// @param name Name of the Token\n    /// @param symbol Symbol of the token\n    /// @param _treasury Treasury address\n    /// @param _supply Initial Supply\n    constructor(\n        string memory name,\n        string memory symbol,\n        address _owner,\n        address _treasury,\n        uint256 _supply\n    ) ERC20(name, symbol) {\n        require(_treasury != address(0), \"Treasury can't be zero address\");\n        require(_owner != address(0), \"Owner can't be zero address\");\n        _mint(_treasury, _supply);\n        _transferOwnership(_owner);\n    }\n\n    function pause(bool stop) public onlyOwner {\n        if (stop) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /// @notice Verifications before Token Transfer\n    /// @param from Address from\n    /// @param from to Address from\n    /// @param amount tokens to be transferred\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "contracts/BlastEquipmentNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\r\nimport \"@prb/math/contracts/PRBMathUD60x18.sol\";\r\nimport \"./interfaces/IBlastEquipmentNFT.sol\";\r\nimport {Errors} from \"./libraries/Errors.sol\";\r\n\r\n/// @title Blast Equipment NFT\r\n/// @dev BlastNFT ERC721 token\r\ncontract BlastEquipmentNFT is\r\n    ERC721,\r\n    IBlastEquipmentNFT,\r\n    ERC721URIStorage,\r\n    ERC721Burnable,\r\n    Pausable,\r\n    AccessControl\r\n{\r\n    using Counters for Counters.Counter;\r\n    using SafeERC20 for IERC20;\r\n    using PRBMathUD60x18 for uint256;\r\n\r\n    /// @dev Variable Attributes\r\n    /// @notice These attributes would be nice to have on-chain because they affect the value of NFT and they are persistent when NFT changes hands.\r\n    struct VariableAttributes {\r\n        uint256 level;\r\n        uint256 durabilityRestored;\r\n        uint256 durability;\r\n        uint256 lastRepairTime;\r\n        uint256 repairCount;\r\n        uint256 replicationCount;\r\n    }\r\n\r\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\r\n    bytes32 public constant GAME_ROLE = keccak256(\"GAME_ROLE\");\r\n    bytes32 public constant REVEAL_ROLE = keccak256(\"REVEAL_ROLE\");\r\n    bytes32 public constant REPLICATOR_ROLE = keccak256(\"REPLICATOR_ROLE\");\r\n\r\n    Counters.Counter public _tokenIdCounter;\r\n    uint256 public durabilityPointTimer = 1 weeks;\r\n    mapping(uint256 => bytes32) public hashValue;\r\n    mapping(uint256 => VariableAttributes) public attributes;\r\n    mapping(uint256 => StaticAttributes) public staticAttributes;\r\n    mapping(uint256 => uint256) private revealed;\r\n    mapping(uint256 => string) private realTokenURI;\r\n    string private previewURI;\r\n    string private baseURI;\r\n\r\n    modifier hasGameRole() {\r\n        require(\r\n            hasRole(GAME_ROLE, _msgSender()) ||\r\n                hasRole(DEFAULT_ADMIN_ROLE, _msgSender()) ||\r\n                hasRole(REPLICATOR_ROLE, _msgSender()),\r\n            Errors.MISSING_GAME_ROLE\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\r\n    /// @param name Name of the contract\r\n    /// @param symbol Symbol of the contract\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        string memory _previewURI,\r\n        string memory _baseURI\r\n    ) ERC721(name, symbol) {\r\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\r\n        _setupRole(MINTER_ROLE, _msgSender());\r\n        _setupRole(GAME_ROLE, _msgSender());\r\n        _setupRole(REVEAL_ROLE, _msgSender());\r\n        _setupRole(REPLICATOR_ROLE, _msgSender());\r\n\r\n        previewURI = _previewURI;\r\n        baseURI = _baseURI;\r\n    }\r\n\r\n    /// @notice Creates a new token for `to`. Its token ID will be automatically\r\n    /// @dev The caller must have the `MINTER_ROLE`.\r\n    function safeMint(\r\n        address _to,\r\n        bytes32[] calldata _hash,\r\n        string[] calldata _realUri,\r\n        StaticAttributes[] calldata _staticAttributes\r\n    ) external onlyRole(MINTER_ROLE) {\r\n        require(_to != address(0), Errors.NO_ZERO_ADDRESS);\r\n        require(_hash.length == _realUri.length, Errors.INVALID_PARAM);\r\n\r\n        for (uint256 i = 0; i < _hash.length; i = i + 1) {\r\n            _safeMint(_to, _hash[i], _realUri[i], _staticAttributes[i]);\r\n        }\r\n    }\r\n\r\n    function safeMintReplicator(\r\n        address _to,\r\n        bytes32 _hash,\r\n        string calldata _realUri,\r\n        StaticAttributes memory _staticAttributes\r\n    ) external override onlyRole(REPLICATOR_ROLE) returns (uint256) {\r\n        require(_to != address(0), Errors.NO_ZERO_ADDRESS);\r\n\r\n        return _safeMint(_to, _hash, _realUri, _staticAttributes);\r\n    }\r\n\r\n    function _safeMint(\r\n        address _to,\r\n        bytes32 _hash,\r\n        string memory _realUri,\r\n        StaticAttributes memory _staticAttributes\r\n    ) internal returns (uint256) {\r\n        uint256 tokenId = _tokenIdCounter.current();\r\n        _tokenIdCounter.increment();\r\n        hashValue[tokenId] = _hash;\r\n        realTokenURI[tokenId] = _realUri;\r\n        attributes[tokenId] = VariableAttributes({\r\n            level: 1,\r\n            durabilityRestored: 0,\r\n            durability: 0,\r\n            lastRepairTime: block.timestamp,\r\n            repairCount: 0,\r\n            replicationCount: 0\r\n        });\r\n        staticAttributes[tokenId] = _staticAttributes;\r\n\r\n        _mint(_to, tokenId);\r\n\r\n        emit AttributeUpdated(tokenId, 1, 0, 0, block.timestamp, 0, 0);\r\n\r\n        return tokenId;\r\n    }\r\n\r\n    function revealRealTokenURI(\r\n        uint256 _tokenId\r\n    ) external override onlyRole(REVEAL_ROLE) {\r\n        revealed[_tokenId] = 1;\r\n        VariableAttributes storage _variableAttribute = attributes[_tokenId];\r\n        _variableAttribute.lastRepairTime = block.timestamp;\r\n\r\n        emit PermanentURI(realTokenURI[_tokenId], _tokenId);\r\n    }\r\n\r\n    function setRealTokenURI(\r\n        uint256 _tokenId,\r\n        string calldata _realUri\r\n    ) external override onlyRole(REVEAL_ROLE) {\r\n        realTokenURI[_tokenId] = _realUri;\r\n        emit PermanentURI(_realUri, _tokenId);\r\n    }\r\n\r\n    function setPreviewTokenURI(\r\n        string calldata _previewURI\r\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        previewURI = _previewURI;\r\n    }\r\n\r\n    function setLevel(\r\n        uint256 _tokenId,\r\n        uint256 _newLevel\r\n    ) external override hasGameRole {\r\n        StaticAttributes memory _staticAttribute = staticAttributes[_tokenId];\r\n        require(\r\n            _staticAttribute.maxLevel >= _newLevel,\r\n            Errors.MAX_LEVEL_REACHED\r\n        );\r\n\r\n        VariableAttributes storage _attribute = attributes[_tokenId];\r\n        _attribute.level = _newLevel;\r\n        uint256 _durabilityPoint = getDurabilityPoints(_attribute, _tokenId);\r\n        emit AttributeUpdated(\r\n            _tokenId,\r\n            _newLevel,\r\n            _attribute.durabilityRestored,\r\n            _durabilityPoint,\r\n            _attribute.lastRepairTime,\r\n            _attribute.repairCount,\r\n            _attribute.replicationCount\r\n        );\r\n    }\r\n\r\n    function setRepairCount(\r\n        uint256 _tokenId,\r\n        uint256 _newRepairCount\r\n    ) external override hasGameRole {\r\n        VariableAttributes storage _attribute = attributes[_tokenId];\r\n\r\n        _attribute.repairCount = _newRepairCount;\r\n        _attribute.durabilityRestored += getDurabilityPoints(\r\n            _attribute,\r\n            _tokenId\r\n        );\r\n        _attribute.lastRepairTime = block.timestamp;\r\n\r\n        uint256 _durabilityPoint = getDurabilityPoints(_attribute, _tokenId);\r\n        emit AttributeUpdated(\r\n            _tokenId,\r\n            _attribute.level,\r\n            _attribute.durabilityRestored,\r\n            _durabilityPoint,\r\n            _attribute.lastRepairTime,\r\n            _newRepairCount,\r\n            _attribute.replicationCount\r\n        );\r\n    }\r\n\r\n    function setReplicationCount(\r\n        uint256 _tokenId,\r\n        uint256 _newReplicationCount\r\n    ) external override hasGameRole {\r\n        StaticAttributes memory _staticAttribute = staticAttributes[_tokenId];\r\n        require(\r\n            _staticAttribute.maxReplication >= _newReplicationCount,\r\n            Errors.MAX_REPLICATION_COUNT_REACHED\r\n        );\r\n\r\n        VariableAttributes storage _attribute = attributes[_tokenId];\r\n        _attribute.replicationCount = _newReplicationCount;\r\n        uint256 _durabilityPoint = getDurabilityPoints(_attribute, _tokenId);\r\n        emit AttributeUpdated(\r\n            _tokenId,\r\n            _attribute.level,\r\n            _attribute.durabilityRestored,\r\n            _durabilityPoint,\r\n            _attribute.lastRepairTime,\r\n            _attribute.repairCount,\r\n            _newReplicationCount\r\n        );\r\n    }\r\n\r\n    function scrap(uint256 _tokenId) external override hasGameRole {\r\n        _burn(_tokenId);\r\n        delete attributes[_tokenId];\r\n        delete staticAttributes[_tokenId];\r\n        delete hashValue[_tokenId];\r\n        delete realTokenURI[_tokenId];\r\n    }\r\n\r\n    function getAttributes(\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        view\r\n        override\r\n        returns (uint256, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        VariableAttributes memory _attribute = attributes[_tokenId];\r\n        uint256 _durabilityPoint = getDurabilityPoints(_attribute, _tokenId);\r\n        return (\r\n            _attribute.level,\r\n            _attribute.durabilityRestored,\r\n            _durabilityPoint,\r\n            _attribute.lastRepairTime,\r\n            _attribute.repairCount,\r\n            _attribute.replicationCount\r\n        );\r\n    }\r\n\r\n    function getStaticAttributes(\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        view\r\n        override\r\n        returns (uint8, uint8, uint8, uint8, uint8, uint8)\r\n    {\r\n        StaticAttributes memory _attribute = staticAttributes[_tokenId];\r\n        return (\r\n            _attribute.maxLevel,\r\n            _attribute.maxDurability,\r\n            _attribute.maxReplication,\r\n            _attribute.adjective,\r\n            _attribute.rarity,\r\n            _attribute.grade\r\n        );\r\n    }\r\n\r\n    function getDurabilityPoints(\r\n        VariableAttributes memory _attribute,\r\n        uint256 _tokenId\r\n    ) internal view returns (uint256) {\r\n        StaticAttributes memory _staticAttribute = staticAttributes[_tokenId];\r\n        uint256 _durabilityPoint = (block.timestamp -\r\n            _attribute.lastRepairTime) / durabilityPointTimer;\r\n        return (\r\n            _durabilityPoint >= _staticAttribute.maxDurability\r\n                ? _staticAttribute.maxDurability\r\n                : _durabilityPoint\r\n        );\r\n    }\r\n\r\n    function setStaticAttributes(\r\n        uint256 _tokenId,\r\n        StaticAttributes calldata _staticAttributes\r\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        staticAttributes[_tokenId] = _staticAttributes;\r\n    }\r\n\r\n    /// @notice Set the DurabilityPoint Timer\r\n    /// @dev The caller must have the `DEFAULT_ADMIN_ROLE`.\r\n    function setDurabilityPointTimer(\r\n        uint256 _newTimer\r\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        require(_newTimer > 0, Errors.INVALID_PARAM);\r\n        durabilityPointTimer = _newTimer;\r\n    }\r\n\r\n    /// @notice Set BaseURI for token metadata URI\r\n    /// @dev The caller must have the `DEFAULT_ADMIN_ROLE`.\r\n    function setBaseURI(\r\n        string memory _baseURI\r\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        baseURI = _baseURI;\r\n    }\r\n\r\n    // @notice Pauses/Unpauses the contract\r\n    // @dev While paused, actions are not allowed\r\n    // @param stop whether to pause or unpause the contract.\r\n    function pause(bool stop) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        if (stop) {\r\n            _pause();\r\n        } else {\r\n            _unpause();\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual override whenNotPaused {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    /// @notice Unpauses all token transfers.\r\n    /// @dev The caller must be the Owner (or have approval) of the Token.\r\n    /// @param tokenId Token ID.\r\n    function _burn(\r\n        uint256 tokenId\r\n    ) internal override(ERC721, ERC721URIStorage) {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), Errors.NOT_OWNER);\r\n        super._burn(tokenId);\r\n    }\r\n\r\n    /// @notice Returns the TokenURI.\r\n    /// @param tokenId Token ID.\r\n    function tokenURI(\r\n        uint256 tokenId\r\n    ) public view override(ERC721, ERC721URIStorage) returns (string memory) {\r\n        _requireMinted(tokenId);\r\n\r\n        if (revealed[tokenId] == 0) {\r\n            return previewURI;\r\n        }\r\n        return string(abi.encodePacked(baseURI, realTokenURI[tokenId]));\r\n    }\r\n\r\n    /// @dev See {IERC165-supportsInterface}.\r\n    /// @param interfaceId Interface ID.\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    )\r\n        public\r\n        view\r\n        virtual\r\n        override(AccessControl, ERC721, IERC165)\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n"
    },
    "@prb/math/contracts/PRBMathUD60x18.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./PRBMath.sol\";\n\n/// @title PRBMathUD60x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\n/// maximum values permitted by the Solidity type uint256.\nlibrary PRBMathUD60x18 {\n    /// @dev Half the SCALE number.\n    uint256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\n    uint256 internal constant LOG2_E = 1_442695040888963407;\n\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\n\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_WHOLE_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // The operations can never overflow.\n        unchecked {\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function ceil(uint256 x) internal pure returns (uint256 result) {\n        if (x > MAX_WHOLE_UD60x18) {\n            revert PRBMathUD60x18__CeilOverflow(x);\n        }\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"SCALE - remainder\" but faster.\n            let delta := sub(SCALE, remainder)\n\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\n            result := add(x, mul(delta, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\n    ///\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    ///\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDiv(x, SCALE, y);\n    }\n\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (uint256 result) {\n        result = 2_718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp(uint256 x) internal pure returns (uint256 result) {\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133_084258667509499441) {\n            revert PRBMathUD60x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            uint256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (x >= 192e18) {\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x192x64 = (x << 64) / SCALE;\n\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\n            result = PRBMath.exp2(x192x64);\n        }\n    }\n\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function floor(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\n            result := sub(x, mul(remainder, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x.\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\n    function frac(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            result := mod(x, SCALE)\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__FromUintOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\n    ///\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            uint256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathUD60x18__GmOverflow(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = PRBMath.sqrt(xy);\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding toward zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\n    function inv(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\n    function ln(uint256 x) internal pure returns (uint256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 196205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log10(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\n        // in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\n            default {\n                result := MAX_UD60x18\n            }\n        }\n\n        if (result == MAX_UD60x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3_321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\n    ///\n    /// Caveats:\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log2(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\n\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255 and SCALE is 1e18.\n            result = n * SCALE;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n        }\n    }\n\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\n    /// fixed-point number.\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDivFixedPoint(x, y);\n    }\n\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\n    function pi() internal pure returns (uint256 result) {\n        result = 3_141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : uint256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// Caveats:\n    /// - All from \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // Calculate the first iteration of the loop in advance.\n        result = y & 1 > 0 ? x : SCALE;\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        for (y >>= 1; y > 0; y >>= 1) {\n            x = PRBMath.mulDivFixedPoint(x, x);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (y & 1 > 0) {\n                result = PRBMath.mulDivFixedPoint(result, x);\n            }\n        }\n    }\n\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\n    function scale() internal pure returns (uint256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x must be less than MAX_UD60x18 / SCALE.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = PRBMath.sqrt(x * SCALE);\n        }\n    }\n\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n"
    },
    "@prb/math/contracts/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    },
    "contracts/Utilities/Repairing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@prb/math/contracts/PRBMathUD60x18.sol\";\nimport \"./../interfaces/IBlastEquipmentNFT.sol\";\nimport \"./Utility.sol\";\n\ncontract Repairing is Utility {\n    using SafeERC20 for IERC20;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 private basePowerForCS = 2500; // 2.5\n    uint256 private basePowerForBLST = 2025; // 2.025\n    uint256 private basePriceForCS = 20000; // 20\n    uint256 private basePriceForBLST = 50; // 0.05\n    uint256 private basePriceForMATIC = 5; // 0.05\n    uint16 private significanceK = 200; // DECIMAL_FACTOR 100\n\n    event Repaired(uint256 tokenId, uint256 repairTimestamp);\n\n    constructor(\n        IBlastEquipmentNFT _blastEquipmentNFT,\n        IERC20 _blastToken,\n        ERC20Burnable _csToken,\n        address _treasuryAddress,\n        address _companyAddress\n    ) Utility(_blastEquipmentNFT, _blastToken, _csToken, _treasuryAddress, _companyAddress) {\n    }\n\n    function getRepairPrice(uint256 _tokenId) public view returns (uint256) {\n        (, uint256 durabilityRestored, uint256 durabilityPoint, , , ) = blastEquipmentNFT.getAttributes(_tokenId);\n        uint256 temp = ((durabilityRestored * significanceK + DECIMAL_FACTOR) * durabilityPoint) * 10 ** 18 / DECIMAL_FACTOR;\n        if (temp == 0) {\n            return 0;\n        }\n        return PRBMathUD60x18.exp2(PRBMathUD60x18.div(PRBMathUD60x18.mul(PRBMathUD60x18.log2(temp), basePowerForCS), DECIMAL_FACTOR)) * basePriceForCS / DECIMAL_FACTOR;\n    }\n\n    function getRepairPriceBLST(uint256 _tokenId) public view returns (uint256) {\n        (, uint256 durabilityRestored, uint256 durabilityPoint, , , ) = blastEquipmentNFT.getAttributes(_tokenId);\n        if ((durabilityRestored + durabilityPoint) > 6) {\n            uint256 temp = ((durabilityRestored + 1) * durabilityPoint);\n            if (temp == 0) {\n                return 0;\n            }\n            return PRBMathUD60x18.exp2(PRBMathUD60x18.div(PRBMathUD60x18.mul(PRBMathUD60x18.log2(temp * 10 ** 18), basePowerForBLST), DECIMAL_FACTOR)) * (isUsingMatic ? basePriceForMATIC : basePriceForBLST) / DECIMAL_FACTOR;\n        }\n        return 0;\n    }\n\n    /// @notice Set Base Power for CS and BLST. It will affect to calculate repair price for CS & BLST\n    /// @dev The caller must have the `DEFAULT_ADMIN_ROLE`.\n    function setBasePower(uint256 _basePowerForCS, uint256 _basePowerForBLST) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_basePowerForCS > 0, Errors.NO_ZERO_VALUE);\n        require(_basePowerForBLST > 0, Errors.NO_ZERO_VALUE);\n\n        basePowerForCS = _basePowerForCS;\n        basePowerForBLST = _basePowerForBLST;\n    }\n\n    /// @notice Set significanceK value\n    /// @dev The caller must have the `DEFAULT_ADMIN_ROLE`.\n    function setSignificanceK(uint16 _significanceK) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_significanceK > 0, Errors.NO_ZERO_VALUE);\n        significanceK = _significanceK;\n    }\n\n    /// @notice Set Base Price for CS and BLST. It will affect to calculate repair price for CS & BLST\n    /// @dev The caller must have the `DEFAULT_ADMIN_ROLE`.\n    function setBasePrice(uint256 _basePriceForCS, uint256 _basePriceForBLST, uint256 _basePriceForMATIC) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_basePriceForCS > 0, Errors.NO_ZERO_VALUE);\n        require(_basePriceForBLST > 0, Errors.NO_ZERO_VALUE);\n        require(_basePriceForMATIC > 0, Errors.NO_ZERO_VALUE);\n\n        basePriceForCS = _basePriceForCS;\n        basePriceForBLST = _basePriceForBLST;\n        basePriceForMATIC = _basePriceForMATIC;\n    }\n\n    function repair(\n        uint256 _tokenId\n    ) external nonReentrant whenNotPaused {\n        require(!isUsingMatic, Errors.USING_MATIC_NOW);\n        require(blastEquipmentNFT.ownerOf(_tokenId) == _msgSender(), Errors.NOT_OWNER);\n        (, uint256 durabilityRestored, uint256 durabilityPoints, , uint256 repairCount, ) = blastEquipmentNFT.getAttributes(_tokenId);\n        if ((durabilityRestored + durabilityPoints) > 6) {\n            uint256 blstPrice = getRepairPriceBLST(_tokenId);\n            require(blstPrice > 0, Errors.INVALID_AMOUNT);\n\n            // Safe TransferFrom from msgSender to treasury\n            blastToken.safeTransferFrom(_msgSender(), treasuryAddress, blstPrice / 4);\n            blastToken.safeTransferFrom(_msgSender(), companyAddress, (blstPrice - blstPrice / 4));\n        } else {\n            uint256 price = getRepairPrice(_tokenId);\n            require(price > 0, Errors.INVALID_AMOUNT);\n\n            // Burning CS token from msgSender\n            csToken.burnFrom(_msgSender(), price);\n        }\n\n        blastEquipmentNFT.setRepairCount(_tokenId, repairCount + 1);\n\n        emit Repaired(_tokenId, block.timestamp);\n    }\n\n    function repairUsingMatic(uint256 _tokenId) external payable nonReentrant whenNotPaused {\n        require(isUsingMatic, Errors.NOT_USING_MATIC_NOW);\n        require(blastEquipmentNFT.ownerOf(_tokenId) == _msgSender(), Errors.NOT_OWNER);\n\n        uint256 durabilityRestored;\n        uint256 durabilityPoints;\n        uint256 repairCount;\n        (, durabilityRestored, durabilityPoints, , repairCount, ) = blastEquipmentNFT.getAttributes(_tokenId);\n        if ((durabilityRestored + durabilityPoints) > 6) {\n            uint256 maticPrice = getRepairPriceBLST(_tokenId);\n            require(maticPrice > 0, Errors.INVALID_AMOUNT);\n            require(msg.value == maticPrice, Errors.INVALID_AMOUNT);\n\n            // Safe TransferFrom from msgSender to treasury\n            (bool sent1, ) = payable(treasuryAddress).call{value: maticPrice / 4}(\"\");\n            require(sent1, Errors.FAILED_TO_SEND_ETHER_TREASURY);\n            (bool sent2, ) = payable(companyAddress).call{value: (maticPrice - maticPrice / 4)}(\"\");\n            require(sent2, Errors.FAILED_TO_SEND_ETHER_COMPANY);\n        } else {\n            uint256 price = getRepairPrice(_tokenId);\n            require(price > 0, Errors.INVALID_AMOUNT);\n\n            // Burning CS token from msgSender\n            csToken.burnFrom(_msgSender(), price);\n        }\n\n        blastEquipmentNFT.setRepairCount(_tokenId, repairCount + 1);\n\n        emit Repaired(_tokenId, block.timestamp);\n    }\n}\n"
    },
    "contracts/Marketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { Errors } from \"./libraries/Errors.sol\";\n\nstruct Listing {\n  address owner;\n  bool isActive;\n  uint256 tokenId;\n  uint256 price;\n  IERC20 tokenAddress;\n}\n\n/// @title Blast Royale Token - $BLT\n/// @dev Based on OpenZeppelin Contracts.\ncontract Marketplace is ReentrancyGuard, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  uint public constant DECIMAL_FACTOR = 100_00;\n\n  uint256 public listingCount;\n  uint256 public activeListingCount;\n  uint256 public fee1;\n  address public treasury1;\n  uint256 public fee2;\n  address public treasury2;\n  bool public isUsingMatic;\n\n  mapping (address => bool) public whitelistedTokens;\n  mapping (uint256 => Listing) public listings;\n  IERC721 public erc721Contract;\n\n  /// @notice Event Listed\n  event ItemListed(\n    uint256 listingId,\n    uint256 tokenId,\n    address seller,\n    uint256 price,\n    address payTokenAddress\n  );\n\n  /// @notice Event Delisted\n  event ItemDelisted(\n    uint256 listingId,\n    uint256 tokenId,\n    address seller\n  );\n\n  /// @notice EventItem Sold\n  event ItemSold(\n    uint256 listingId,\n    uint256 tokenId,\n    address seller,\n    address buyer,\n    uint256 price,\n    uint256 fee1,\n    uint256 fee2\n  );\n\n  /// @notice Event Fee changed\n  event FeesChanged(\n    uint256 fee1,\n    address treasury1,\n    uint256 fee2,\n    address treasury2,\n    address changedBy\n  );\n\n  event WhitelistAdded(address[] whitelists);\n\n  event WhitelistRemoved(address[] whitelists);\n\n  /// @notice Token constructor\n  /// @dev Setup the two contracts it will interact with : ERC721 and ERC20\n  /// @param erc721Address Address of the NFT Contract.\n  constructor(IERC721 erc721Address) {\n    require(address(erc721Address) != address(0), Errors.NO_ZERO_ADDRESS);\n    erc721Contract = erc721Address;\n  }\n\n  /// @notice add a Listing to the Marketplace\n  /// @dev Creates a new entry for a Listing object and transfers the Token to the contract\n  /// @param tokenId NFT TokenId.\n  /// @param price Price in NFTs.\n  function addListing(uint256 tokenId, uint256 price, IERC20 payTokenAddress) public nonReentrant whenNotPaused\n  {\n    require(price != 0, Errors.NO_ZERO_VALUE);\n    if (address(payTokenAddress) != address(0)) {\n      require(whitelistedTokens[address(payTokenAddress)], Errors.TOKEN_NOT_WHITELISTED);\n    }\n\n    uint256 listingId = listingCount;\n    listings[listingId] = Listing({\n      owner: _msgSender(),\n      isActive: true,\n      tokenId: tokenId,\n      price: price,\n      tokenAddress: payTokenAddress\n    });\n    listingCount = listingCount + 1;\n    activeListingCount = activeListingCount + 1;\n    erc721Contract.transferFrom(\n      _msgSender(),\n      address(this),\n      tokenId\n    );\n\n    emit ItemListed(listingId, tokenId, _msgSender(), price, address(payTokenAddress));\n  }\n\n  /// @notice Remove a Listing from the Marketplace\n  /// @dev Marks Listing as not active object and transfers the Token back\n  /// @param listingId NFT Listing Id.\n  function removeListing(uint256 listingId) public nonReentrant\n  {\n    Listing storage listing = listings[listingId];\n    require(listing.owner == _msgSender() || owner() == _msgSender(), Errors.NOT_OWNER);\n    require(listing.isActive, Errors.LISTING_IS_NOT_ACTIVED);\n    listing.isActive = false;\n    erc721Contract.transferFrom(\n      address(this),\n      listing.owner,\n      listing.tokenId\n    );\n    activeListingCount = activeListingCount - 1;\n    emit ItemDelisted(listingId, listing.tokenId, listing.owner);\n  }\n\n  /// @notice Buys a listed NFT\n  /// @dev Trabsfers both the ERC20 token (price) and the NFT.\n  /// @param listingId NFT Listing Id.\n  function buy(uint256 listingId) public payable nonReentrant whenNotPaused\n  {\n    require(listings[listingId].isActive, Errors.LISTING_IS_NOT_ACTIVED);\n\n    listings[listingId].isActive = false;\n    IERC20 payTokenAddress = listings[listingId].tokenAddress;\n    uint listedPrice = listings[listingId].price;\n    uint256 buyingFee1 = (fee1 * listedPrice / DECIMAL_FACTOR);\n    uint256 buyingFee2 = (fee2 * listedPrice / DECIMAL_FACTOR);\n\n    if (isUsingMatic) {\n      require(msg.value == listedPrice, Errors.INVALID_AMOUNT);\n      if (buyingFee1 > 0) {\n        (bool sent1, ) = payable(treasury1).call{value: buyingFee1}(\"\");\n        require(sent1, Errors.FAILED_TO_SEND_ETHER_TREASURY);\n      }\n      if (buyingFee2 > 0) {\n        (bool sent2, ) = payable(treasury2).call{value: buyingFee2}(\"\");\n        require(sent2, Errors.FAILED_TO_SEND_ETHER_COMPANY);\n      }\n      (bool sent, ) = payable(listings[listingId].owner).call{value: listedPrice - buyingFee1 - buyingFee2}(\"\");\n      require(sent, Errors.FAILED_TO_SEND_ETHER_USER);\n    } else {\n      require(msg.value == 0, Errors.INVALID_AMOUNT);\n      if (buyingFee1 > 0) {\n        payTokenAddress.safeTransferFrom(\n          _msgSender(),\n          treasury1,\n          buyingFee1\n        );\n      }\n      if (buyingFee2 > 0) {\n        payTokenAddress.safeTransferFrom(\n          _msgSender(),\n          treasury2,\n          buyingFee2\n        );\n      }\n      payTokenAddress.safeTransferFrom(\n        _msgSender(),\n        listings[listingId].owner,\n        listedPrice - buyingFee1 - buyingFee2\n      );\n    }\n    erc721Contract.transferFrom(\n      address(this),\n      _msgSender(),\n      listings[listingId].tokenId\n    );\n    activeListingCount = activeListingCount - 1;\n\n    emit ItemSold(\n      listingId,\n      listings[listingId].tokenId,\n      listings[listingId].owner,\n      _msgSender(),\n      listedPrice,\n      buyingFee1,\n      buyingFee2\n    );\n  }\n\n  /// @notice Sets a new Fee\n  /// @param _fee1 new Fee1.\n  /// @param _treasury1 New treasury1 address.\n  /// @param _fee2 new Fee2.\n  /// @param _treasury2 New treasury2 address.\n  function setFee(uint256 _fee1, address _treasury1, uint256 _fee2, address _treasury2) public onlyOwner\n  {\n    require(_fee1 + _fee2 < DECIMAL_FACTOR, Errors.INVALID_PARAM);\n    require(_treasury1 != address(0), Errors.NO_ZERO_ADDRESS);\n    require(_treasury2 != address(0), Errors.NO_ZERO_ADDRESS);\n\n    fee1 = _fee1;\n    treasury1 = _treasury1;\n    fee2 = _fee2;\n    treasury2 = _treasury2;\n\n    emit FeesChanged(\n      fee1,\n      treasury1,\n      fee2,\n      treasury2,\n      _msgSender()\n    );\n  }\n\n  function setWhitelistTokens(address[] calldata _whitelist) external onlyOwner {\n    for (uint i = 0; i < _whitelist.length; i++) {\n      require(_whitelist[i] != address(0), Errors.NO_ZERO_ADDRESS);\n      whitelistedTokens[_whitelist[i]] = true;\n    }\n\n    emit WhitelistAdded(_whitelist);\n  }\n\n  function removeWhitelistTokens(address[] calldata _whitelist) external onlyOwner {\n    for (uint i = 0; i < _whitelist.length; i++) {\n      require(_whitelist[i] != address(0), Errors.NO_ZERO_ADDRESS);\n      whitelistedTokens[_whitelist[i]] = false;\n    }\n\n    emit WhitelistRemoved(_whitelist);\n  }\n\n  function flipIsUsingMatic() external onlyOwner {\n    isUsingMatic = !isUsingMatic;\n  }\n\n  // @notice Pauses/Unpauses the contract\n  // @dev While paused, addListing, and buy are not allowed\n  // @param stop whether to pause or unpause the contract.\n  function pause(bool stop) external onlyOwner {\n    if (stop) {\n      _pause();\n    } else {\n      _unpause();\n    }\n  }\n}\n\n"
    },
    "contracts/CSMarketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\n\nstruct Listing {\n    address owner;\n    bool isActive;\n    uint256 amount;\n    uint256 price;\n    IERC20 tokenAddress;\n}\n\n/// @title Blast Royale Token - $BLT\n/// @dev Based on OpenZeppelin Contracts.\ncontract CSMarketplace is ReentrancyGuard, Ownable, Pausable {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant DECIMAL_FACTOR = 100_00;\n\n    uint256 public listingCount;\n    uint256 public activeListingCount;\n    uint256 public fee1;\n    address public treasury1;\n    uint256 public fee2;\n    address public treasury2;\n    bool public isUsingMatic;\n\n    mapping(address => bool) public whitelistedTokens;\n    mapping(uint256 => Listing) public listings;\n    IERC20 public erc20Contract;\n\n    /// @notice Event Listed\n    event CSListed(\n        uint256 listingId,\n        uint256 amount,\n        address seller,\n        uint256 price,\n        address payTokenAddress\n    );\n\n    /// @notice Event Delisted\n    event CSDelisted(uint256 listingId, uint256 amount, address seller);\n\n    /// @notice EventItem Sold\n    event CSSold(\n        uint256 listingId,\n        uint256 amount,\n        address seller,\n        address buyer,\n        uint256 price,\n        uint256 fee1,\n        uint256 fee2\n    );\n\n    /// @notice Event Fee changed\n    event FeesChanged(\n        uint256 fee1,\n        address treasury1,\n        uint256 fee2,\n        address treasury2,\n        address changedBy\n    );\n\n    event WhitelistAdded(address[] whitelists);\n\n    event WhitelistRemoved(address[] whitelists);\n\n    /// @notice Token constructor\n    /// @dev Setup the two contracts it will interact with : CS token and ERC20\n    /// @param erc20Address Address of the CS Contract.\n    constructor(IERC20 erc20Address) {\n        require(address(erc20Address) != address(0), Errors.NO_ZERO_ADDRESS);\n        erc20Contract = erc20Address;\n    }\n\n    /// @notice add a Listing to the Marketplace\n    /// @dev Creates a new entry for a Listing object and transfers the Token to the contract\n    /// @param amount amount of CS.\n    /// @param price Price of CS.\n    function addListing(\n        uint256 amount,\n        uint256 price,\n        IERC20 payTokenAddress\n    ) public nonReentrant whenNotPaused {\n        require(price != 0, Errors.NO_ZERO_VALUE);\n        if (address(payTokenAddress) != address(0)) {\n            require(\n                whitelistedTokens[address(payTokenAddress)],\n                Errors.TOKEN_NOT_WHITELISTED\n            );\n        }\n\n        uint256 listingId = listingCount;\n        listings[listingId] = Listing({\n            owner: _msgSender(),\n            isActive: true,\n            amount: amount,\n            price: price,\n            tokenAddress: payTokenAddress\n        });\n        listingCount = listingCount + 1;\n        activeListingCount = activeListingCount + 1;\n        erc20Contract.safeTransferFrom(_msgSender(), address(this), amount);\n\n        emit CSListed(\n            listingId,\n            amount,\n            _msgSender(),\n            price,\n            address(payTokenAddress)\n        );\n    }\n\n    /// @notice Remove a Listing from the Marketplace\n    /// @dev Marks Listing as not active object and transfers the Token back\n    /// @param listingId CS Listing Id.\n    function removeListing(uint256 listingId) public nonReentrant {\n        Listing storage listing = listings[listingId];\n        require(\n            listing.owner == _msgSender() || owner() == _msgSender(),\n            Errors.NOT_OWNER\n        );\n        require(listing.isActive, Errors.LISTING_IS_NOT_ACTIVED);\n        listing.isActive = false;\n        erc20Contract.transfer(listing.owner, listing.amount);\n        activeListingCount = activeListingCount - 1;\n        emit CSDelisted(listingId, listing.amount, listing.owner);\n    }\n\n    /// @notice Buys an amount of listed CS\n    /// @dev Trabsfers both the ERC20 token (price) and CS.\n    /// @param listingId CS Listing Id.\n    function buy(uint256 listingId) public payable nonReentrant whenNotPaused {\n        require(listings[listingId].isActive, Errors.LISTING_IS_NOT_ACTIVED);\n\n        listings[listingId].isActive = false;\n        IERC20 payTokenAddress = listings[listingId].tokenAddress;\n        uint256 listedPrice = listings[listingId].price;\n        uint256 buyingFee1 = ((fee1 * listedPrice) / DECIMAL_FACTOR);\n        uint256 buyingFee2 = ((fee2 * listedPrice) / DECIMAL_FACTOR);\n\n        if (isUsingMatic) {\n            require(msg.value == listedPrice, Errors.INVALID_AMOUNT);\n            if (buyingFee1 > 0) {\n                (bool sent1, ) = payable(treasury1).call{value: buyingFee1}(\"\");\n                require(sent1, Errors.FAILED_TO_SEND_ETHER_TREASURY);\n            }\n            if (buyingFee2 > 0) {\n                (bool sent2, ) = payable(treasury2).call{value: buyingFee2}(\"\");\n                require(sent2, Errors.FAILED_TO_SEND_ETHER_COMPANY);\n            }\n            (bool sent, ) = payable(listings[listingId].owner).call{\n                value: listedPrice - buyingFee1 - buyingFee2\n            }(\"\");\n            require(sent, Errors.FAILED_TO_SEND_ETHER_USER);\n        } else {\n            require(msg.value == 0, Errors.INVALID_AMOUNT);\n            if (buyingFee1 > 0) {\n                payTokenAddress.safeTransferFrom(\n                    _msgSender(),\n                    treasury1,\n                    buyingFee1\n                );\n            }\n            if (buyingFee2 > 0) {\n                payTokenAddress.safeTransferFrom(\n                    _msgSender(),\n                    treasury2,\n                    buyingFee2\n                );\n            }\n            payTokenAddress.safeTransferFrom(\n                _msgSender(),\n                listings[listingId].owner,\n                listedPrice - buyingFee1 - buyingFee2\n            );\n        }\n        erc20Contract.transfer(_msgSender(), listings[listingId].amount);\n        activeListingCount = activeListingCount - 1;\n\n        emit CSSold(\n            listingId,\n            listings[listingId].amount,\n            listings[listingId].owner,\n            _msgSender(),\n            listedPrice,\n            buyingFee1,\n            buyingFee2\n        );\n    }\n\n    /// @notice Sets a new Fee\n    /// @param _fee1 new Fee1.\n    /// @param _treasury1 New treasury1 address.\n    /// @param _fee2 new Fee2.\n    /// @param _treasury2 New treasury2 address.\n    function setFee(\n        uint256 _fee1,\n        address _treasury1,\n        uint256 _fee2,\n        address _treasury2\n    ) public onlyOwner {\n        require(_fee1 + _fee2 < DECIMAL_FACTOR, Errors.INVALID_PARAM);\n        require(_treasury1 != address(0), Errors.NO_ZERO_ADDRESS);\n        require(_treasury2 != address(0), Errors.NO_ZERO_ADDRESS);\n\n        fee1 = _fee1;\n        treasury1 = _treasury1;\n        fee2 = _fee2;\n        treasury2 = _treasury2;\n\n        emit FeesChanged(fee1, treasury1, fee2, treasury2, _msgSender());\n    }\n\n    function setWhitelistTokens(address[] calldata _whitelist)\n        external\n        onlyOwner\n    {\n        for (uint256 i = 0; i < _whitelist.length; i++) {\n            require(_whitelist[i] != address(0), Errors.NO_ZERO_ADDRESS);\n            whitelistedTokens[_whitelist[i]] = true;\n        }\n\n        emit WhitelistAdded(_whitelist);\n    }\n\n    function removeWhitelistTokens(address[] calldata _whitelist)\n        external\n        onlyOwner\n    {\n        for (uint256 i = 0; i < _whitelist.length; i++) {\n            require(_whitelist[i] != address(0), Errors.NO_ZERO_ADDRESS);\n            whitelistedTokens[_whitelist[i]] = false;\n        }\n\n        emit WhitelistRemoved(_whitelist);\n    }\n\n    function flipIsUsingMatic() external onlyOwner {\n        isUsingMatic = !isUsingMatic;\n    }\n\n    // @notice Pauses/Unpauses the contract\n    // @dev While paused, addListing, and buy are not allowed\n    // @param stop whether to pause or unpause the contract.\n    function pause(bool stop) external onlyOwner {\n        if (stop) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}